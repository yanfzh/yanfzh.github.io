<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yanfzh&#39;s  Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-24T12:56:54.933Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yanfzh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot踩坑记录</title>
    <link href="http://yoursite.com/2020/08/24/SpringBoot%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/24/SpringBoot%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-24T12:56:54.000Z</published>
    <updated>2020-08-24T12:56:54.933Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="http://yoursite.com/2020/08/07/Spring-Boot/"/>
    <id>http://yoursite.com/2020/08/07/Spring-Boot/</id>
    <published>2020-08-07T00:51:48.000Z</published>
    <updated>2020-08-09T10:48:07.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ul><li>快速创建独立运行的Spring项目及主流框架的集成</li><li>使用嵌入式Servlet容器，应用无须打包成war包</li><li>无须配置XML，无代码生成，开箱即用<a id="more"></a><h3 id="2-Spring-Boot的创建（IDEA版）"><a href="#2-Spring-Boot的创建（IDEA版）" class="headerlink" title="2. Spring Boot的创建（IDEA版）"></a>2. Spring Boot的创建（IDEA版）</h3><h4 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h4></li></ul><ol><li>创建项目选 Maven 进行，填写好包名等</li><li>在pom.xml文件里写入相关依赖代码，最好去官网查看相关依赖代码，并copy过来，版本最好不要太新，如：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line"> &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line"> &lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li>更新依赖，右侧栏打开Maven,点击 reimport 完成依赖导入更新，右下角有进度，请耐心等待</li><li>写相关代码与注解，例如<code>@SpringBootApplication</code>等</li></ol><p><code>TIP：</code> 执行是出现程序包不存在问题，可能是我自用的2020.1的版本问题，在项目终端中输入 <code>mvn idea:idea</code>可解决。</p><h4 id="2-2-方法二（快捷，IDEA的强大啊）"><a href="#2-2-方法二（快捷，IDEA的强大啊）" class="headerlink" title="2.2 方法二（快捷，IDEA的强大啊）"></a>2.2 方法二（快捷，IDEA的强大啊）</h4><ol><li>创建 spring Initializer 项目</li><li>记得选择所需依赖模块，创建初始化时会自动将依赖写入pom.xml文件并导入</li></ol><ul><li>resources文件夹中目录结构<br>static：保存所有的静态资源： js css  images；<br>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； </li></ul><h3 id="3-项目打成jar包"><a href="#3-项目打成jar包" class="headerlink" title="3. 项目打成jar包"></a>3. 项目打成jar包</h3><ol><li>在 pom.xml 加入以下插件代码，该插件可以将应用打包成jar包，就可以不用再服务器安装tomcat等，直接运行应用<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;build&gt;</span><br><span class="line"> &lt;plugins&gt;</span><br><span class="line"> &lt;plugin&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line"> &lt;/plugin&gt;</span><br><span class="line"> &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li>依次点击右侧栏 maven，spring-boot-test, Lifecycle, package</li><li>在项目target下会生成当前项目的jar包</li><li>运行jar包<br>cmd进入该jar包所在目录<br>输入 <code>java -jar 该jar包完整名称</code><br>打开浏览器输入localhost:8080/hello（也可能是其他窗口，看所给信息）窗口访问</li></ol><p><img src="/images/31.jpg" alt=""><br><img src="/images/30.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-特点&quot;&gt;&lt;a href=&quot;#1-特点&quot; class=&quot;headerlink&quot; title=&quot;1. 特点&quot;&gt;&lt;/a&gt;1. 特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;快速创建独立运行的Spring项目及主流框架的集成&lt;/li&gt;
&lt;li&gt;使用嵌入式Servlet容器，应用无须打包成war包&lt;/li&gt;
&lt;li&gt;无须配置XML，无代码生成，开箱即用
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（下）</title>
    <link href="http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/08/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-08-05T06:25:44.000Z</published>
    <updated>2020-08-05T07:31:03.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h3><h4 id="1-1-死锁产生的必要条件"><a href="#1-1-死锁产生的必要条件" class="headerlink" title="1.1 死锁产生的必要条件"></a>1.1 死锁产生的必要条件</h4><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。<a id="more"></a><h4 id="1-2-死锁的处理方法"><a href="#1-2-死锁的处理方法" class="headerlink" title="1.2 死锁的处理方法"></a>1.2 死锁的处理方法</h4></li></ul><p>主要有以下四种方法：</p><ul><li><p>鸵鸟策略<br>  就忽略掉…</p></li><li><p>死锁检测与死锁恢复</p><ol><li>每种类型一个资源的死锁检测<br> 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li><li>每种类型多个资源的死锁检测<br> 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</li><li>死锁恢复<br> 利用抢占恢复<br> 利用回滚恢复<br> 通过杀死进程恢复</li></ol></li><li><p>死锁预防</p><ol><li>破坏互斥条件</li><li>破坏占有和等待条件<br> 一种实现方式是规定所有进程在开始执行前请求所需的全部资源</li><li>破坏不可强占条件</li><li>破坏环路等待<br> 给统一资源编号，进程只能按编号顺序来请求资源</li></ol></li><li><p>死锁避免<br>  判断一个状态的安全性，若不安全，则拒绝进入状态</p></li></ul><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><h4 id="2-1-虚拟内存"><a href="#2-1-虚拟内存" class="headerlink" title="2.1 虚拟内存"></a>2.1 虚拟内存</h4><ul><li><p>目的：为了让物理内存扩充成更大的逻辑内存，让程序获得更多的可用内存。</p></li><li><p>工作原理：<br>  操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>  虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p></li></ul><h4 id="2-2-分页系统地址映射"><a href="#2-2-分页系统地址映射" class="headerlink" title="2.2 分页系统地址映射"></a>2.2 分页系统地址映射</h4><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><h4 id="2-3-页面置换算法"><a href="#2-3-页面置换算法" class="headerlink" title="2.3 页面置换算法"></a>2.3 页面置换算法</h4><p>主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><ul><li><p>1.最佳（OPT, Optimal replacement algorithm）<br>  所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p></li><li><p>2.最近最久未使用（LRU, Least Recently Used）<br>  可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。<br>  为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p></li><li><p>3.最近未使用（NRU, Not Recently Used）<br>  每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p></li><li><p>4.先进先出（FIFO）<br>  选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面换出，导致缺页率升高。</p></li><li><p>5.时钟（Clock）<br>  时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p></li></ul><h4 id="2-4-分段"><a href="#2-4-分段" class="headerlink" title="2.4 分段"></a>2.4 分段</h4><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h4 id="2-5-段页式"><a href="#2-5-段页式" class="headerlink" title="2.5 段页式"></a>2.5 段页式</h4><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h4 id="2-6-分页与分段的比较"><a href="#2-6-分页与分段的比较" class="headerlink" title="2.6 分页与分段的比较"></a>2.6 分页与分段的比较</h4><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h3 id="3-设备管理"><a href="#3-设备管理" class="headerlink" title="3. 设备管理"></a>3. 设备管理</h3><h4 id="3-1-磁盘结构"><a href="#3-1-磁盘结构" class="headerlink" title="3.1 磁盘结构"></a>3.1 磁盘结构</h4><ol><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。<br><img src="/images/28.jpg" alt=""></li></ol><h4 id="3-2-磁盘调度算法"><a href="#3-2-磁盘调度算法" class="headerlink" title="3.2 磁盘调度算法"></a>3.2 磁盘调度算法</h4><p>读写一个磁盘块的时间的影响因素有：<br>    1. 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<br>    2. 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）<br>    3. 实际的数据传输时间<br>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><ul><li><p>先来先服务（FCFS）<br>  按照磁盘请求的顺序进行调度。优点是公平和简单。缺点是使平均寻道时间可能较长。</p></li><li><p>最短寻道时间优先（SSTF）<br>  优先调度与当前磁头所在磁道距离最近的磁道。<br>  不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p></li><li><p>电梯算法（SCAN）<br>  电梯算法（扫描算法）总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p></li></ul><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接</h3><h4 id="4-1-编译系统"><a href="#4-1-编译系统" class="headerlink" title="4.1 编译系统"></a>4.1 编译系统</h4><p>以下是一个 hello.c 程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printf(<span class="string">"hello, world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。<br>    gcc -o hello hello.c</p><p>这个过程大致如下：<br><img src="/images/29.jpg" alt=""></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h4 id="4-2-静态链接"><a href="#4-2-静态链接" class="headerlink" title="4.2 静态链接"></a>4.2 静态链接</h4><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><h4 id="4-3-目标文件"><a href="#4-3-目标文件" class="headerlink" title="4.3 目标文件"></a>4.3 目标文件</h4><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h4 id="4-4-动态链接"><a href="#4-4-动态链接" class="headerlink" title="4.4 动态链接"></a>4.4 动态链接</h4><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为<code>DLL</code>。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-死锁&quot;&gt;&lt;a href=&quot;#1-死锁&quot; class=&quot;headerlink&quot; title=&quot;1. 死锁&quot;&gt;&lt;/a&gt;1. 死锁&lt;/h3&gt;&lt;h4 id=&quot;1-1-死锁产生的必要条件&quot;&gt;&lt;a href=&quot;#1-1-死锁产生的必要条件&quot; class=&quot;headerlink&quot; title=&quot;1.1 死锁产生的必要条件&quot;&gt;&lt;/a&gt;1.1 死锁产生的必要条件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;互斥：每个资源要么已经分配给了一个进程，要么就是可用的。&lt;/li&gt;
&lt;li&gt;占有和等待：已经得到了某个资源的进程可以再请求新的资源。&lt;/li&gt;
&lt;li&gt;不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。&lt;/li&gt;
&lt;li&gt;环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 （上）</title>
    <link href="http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2020/08/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20(%E4%B8%8A)/</id>
    <published>2020-08-04T05:21:49.000Z</published>
    <updated>2020-08-04T08:08:21.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-基本特征"><a href="#1-1-基本特征" class="headerlink" title="1.1 基本特征"></a>1.1 基本特征</h4><ul><li>并发<br>  并发指一段时间能同时运行多个程序，而并行指同一时刻可运行多个指令<br>  操作系统引入进程、线程实现并发</li><li>共享<br>  分为互斥共享和同时共享，互斥共享的资源称为临界资源，如打印机，同一时刻只允许一个进程访问，需同步机制实现互斥访问</li></ul><a id="more"></a><ul><li>虚拟<ol><li>时（时间）分复用技术： 多个进程可在同一处理器并发执行，进程轮流占用处理器</li><li>空（空间）分复用技术： 应用于虚拟内存，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。</li></ol></li><li>异步<br>  进程不是一次性执行完毕，而是走走停停，以不可知速度向前进</li></ul><h4 id="1-2-基本功能"><a href="#1-2-基本功能" class="headerlink" title="1.2 基本功能"></a>1.2 基本功能</h4><ul><li>进程管理 ：进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li><li>内存管理 ：内存分配、地址映射、内存保护与共享、虚拟内存等。</li><li>文件管理 ：文件存储空间的管理、目录管理、文件读写管理和保护等。</li><li>设备管理 ：缓冲管理、设备分配、设备处理、虛拟设备等。完成I/O 请求，提高设备的利用率。</li></ul><h4 id="1-3-系统调用"><a href="#1-3-系统调用" class="headerlink" title="1.3 系统调用"></a>1.3 系统调用</h4><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><h4 id="1-4-大内核和微内核"><a href="#1-4-大内核和微内核" class="headerlink" title="1.4 大内核和微内核"></a>1.4 大内核和微内核</h4><ul><li><p>大内核<br>  将操作系统功能作为一个紧密结合的整体放入内核<br>  由于各模块共享信息，因此有很高性能</p></li><li><p>微内核<br>  它是由一部分操作系统功能移出内核形成的，降低了内核的复杂性。<br>  在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。<br>  因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p></li></ul><h4 id="1-5-中断分类"><a href="#1-5-中断分类" class="headerlink" title="1.5 中断分类"></a>1.5 中断分类</h4><ul><li><p>外中断<br>  由 CPU 执行指令以外的事件引起，<br>  如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。</p></li><li><p>异常<br>  由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p></li><li><p>陷入<br>  在用户程序中使用系统调用。</p></li></ul><h3 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2. 进程管理"></a>2. 进程管理</h3><h4 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h4><ul><li><p>进程<br>  进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p></li><li><p>线程<br>  线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。</p></li><li><p>区别</p><ol><li>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li><li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>创建或撤销进程所付出的开销远大于创建或撤销线程时的开销</li><li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li></ol></li></ul><h4 id="2-2-进程状态切换"><a href="#2-2-进程状态切换" class="headerlink" title="2.2 进程状态切换"></a>2.2 进程状态切换</h4><p><img src="/images/26.jpg" alt=""></p><ul><li>就绪状态 (ready) :等待被调度</li><li>运行状态 (running)</li><li>阻塞状态 (waiting) :等待资源</li></ul><p>tips：<br>    1. 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。<br>    2. 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</p><h4 id="2-3-进程调度算法"><a href="#2-3-进程调度算法" class="headerlink" title="2.3 进程调度算法"></a>2.3 进程调度算法</h4><p>不同环境的调度算法目标不同</p><h5 id="2-3-1-批处理系统"><a href="#2-3-1-批处理系统" class="headerlink" title="2.3.1 批处理系统"></a>2.3.1 批处理系统</h5><p>该系统中，调度算法目标是保证吞吐量和周转时间</p><ul><li><p>先来先服务 first-come first-serverd（FCFS）<br>  非抢占式的调度算法，按照请求的顺序进行调度。<br>  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业(执行时间长)执行完毕才能执行</p></li><li><p>短作业优先 shortest job first（SJF）<br>  非抢占式的调度算法，按估计运行时间最短的顺序进行调度。<br>  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。</p></li><li><p>最短剩余时间优先 shortest remaining time next（SRTN）<br>  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。</p></li></ul><h5 id="2-3-2-交互式系统"><a href="#2-3-2-交互式系统" class="headerlink" title="2.3.2 交互式系统"></a>2.3.2 交互式系统</h5><p>有大量用户交互操作，系统中调度算法的目标是快速进行响应。</p><ul><li>时间片轮转<br>  将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</li></ul><p>时间片轮转算法的效率和时间片的大小有很大关系：<br>    1. 因进程切换要保存进程信息并且载入新进程信息，若时间片太小，进程切换频繁，就会花过多时间。<br>    2. 而如果时间片过长，无法保证实时性。</p><ul><li><p>优先级调度<br>  为每个进程分配一个优先级，按优先级进行调度。<br>  为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p></li><li><p>多级反馈队列</p><ol><li>多级队列是为需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</li><li>每个队列优先权也不同，最上面的优先权最高。</li><li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</li></ol></li></ul><h5 id="2-3-3-实时系统"><a href="#2-3-3-实时系统" class="headerlink" title="2.3.3 实时系统"></a>2.3.3 实时系统</h5><p>实时系统要求一个请求在一个确定时间内得到响应。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h4 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h4><ul><li><p>临界区 ：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li><li><p>同步与互斥</p><ol><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ol></li><li><p>信号量（Semaphore）：是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ol><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ol></li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</p><ul><li>管程<ol><li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li><li>管程引入了条件变量以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li></ol></li></ul><h4 id="2-5-进程通信"><a href="#2-5-进程通信" class="headerlink" title="2.5 进程通信"></a>2.5 进程通信</h4><p>进程同步与进程通信区别在于：进程同步控制多个进程按一定顺序执行，进程通信实现进程间信息的传输。</p><ul><li>管道<br>  通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>它具有以下限制：<ol><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ol></li></ul><p><img src="/images/27.jpg" alt=""></p><ul><li><p>FIFO</p><ol><li>也称为命名管道，去除了管道只能在父子进程中使用的限制。</li><li>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</li></ol></li><li><p>消息队列</p></li></ul><p>相比于 FIFO，消息队列具有以下优点：<br>    1. 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；<br>    2. 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；<br>    3. 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</p><ul><li><p>信号量<br>  它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p></li><li><p>共享存储</p><ol><li>多个进程共享一个给定的存储区,这是最快的一种 IPC。</li><li>需要使用信号量用来同步对共享存储的访问。</li><li>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</li></ol></li><li><p>套接字<br>  与其它通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-基本特征&quot;&gt;&lt;a href=&quot;#1-1-基本特征&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本特征&quot;&gt;&lt;/a&gt;1.1 基本特征&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;并发&lt;br&gt;  并发指一段时间能同时运行多个程序，而并行指同一时刻可运行多个指令&lt;br&gt;  操作系统引入进程、线程实现并发&lt;/li&gt;
&lt;li&gt;共享&lt;br&gt;  分为互斥共享和同时共享，互斥共享的资源称为临界资源，如打印机，同一时刻只允许一个进程访问，需同步机制实现互斥访问&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发与多线程</title>
    <link href="http://yoursite.com/2020/07/29/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/29/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-29T08:49:39.000Z</published>
    <updated>2020-07-29T08:52:31.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-并发问题产生的原因"><a href="#1-并发问题产生的原因" class="headerlink" title="1. 并发问题产生的原因"></a>1. 并发问题产生的原因</h3><ul><li>线程的工作内存中保存了该线程中用到的变量的主内存副本<code>拷贝</code>，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</li><li>线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。</li><li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。<a id="more"></a><img src="/images/25.jpg" alt=""></li></ul><h3 id="2-并发三要素"><a href="#2-并发三要素" class="headerlink" title="2. 并发三要素"></a>2. 并发三要素</h3><ol><li><strong>原子性</strong>：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。</li><li><strong>可见性</strong>：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。</li></ol><h3 id="3-并发的解决"><a href="#3-并发的解决" class="headerlink" title="3. 并发的解决"></a>3. 并发的解决</h3><h4 id="3-1-Volatile"><a href="#3-1-Volatile" class="headerlink" title="3.1 Volatile"></a>3.1 Volatile</h4><ul><li><p>volatile 特性</p><ol><li>保证可见性，不保证原子性</li><li>禁止指令重排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 不会对存在依赖关系的指令重排序，例如 a &#x3D; 1;b &#x3D; a; a 和b存在依赖关系，不会被重排序</span><br><span class="line">2. 不能影响单线程下的执行结果。比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作,前两个操作可以重排序，</span><br><span class="line">   但是c&#x3D;a+b不会被重排序，因为要保证结果是3</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用场景</p></li></ul><p>对于一个变量，只有一个线程执行写操作，其它线程都是读操作，这时候可以用 volatile 修饰这个变量。</p><ul><li><p>volatile 原理</p><p>  在JVM底层volatile是采用<code>内存屏障</code>来实现的，内存屏障会提供3个功能：</p><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将缓存的修改操作立即写到主内存</li><li>写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</li></ol></li><li><p>volatile 局限性</p></li></ul><p>volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题。</p><h4 id="3-2-Synchronized"><a href="#3-2-Synchronized" class="headerlink" title="3.2 Synchronized"></a>3.2 Synchronized</h4><ul><li>使用场景</li></ul><p>多个线程同时写一个变量，Synchronized 可以保证同一时刻，只有一个线程可执行某个方法或某个代码块。</p><ul><li>原理</li></ul><p>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一，所以只要这个锁的计数器大于0，其它线程访问就只能等待。</p><ul><li>Synchronized 锁的升级</li></ul><p><strong>偏向锁：</strong>为了让线程获得锁的代价更低，一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。<br><strong>轻量级锁：</strong>在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。<br><strong>重量级锁：</strong>如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。</p><ul><li>Synchronized 缺点</li></ul><ol><li>不能设置锁超时时间</li><li>不能通过代码释放锁</li><li>容易造成死锁</li></ol><h4 id="3-3-ReentrantLock"><a href="#3-3-ReentrantLock" class="headerlink" title="3.3 ReentrantLock"></a>3.3 ReentrantLock</h4><ol><li>它可以设置锁超时时间和，能通过代码释放锁</li><li>在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适</li><li>ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。</li></ol><ul><li><p>使用</p><ol><li>lock 和unlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ReentrantLock reentrantLock &#x3D; new ReentrantLock();</span><br><span class="line">System.out.println(&quot;reentrantLock-&gt;lock&quot;);</span><br><span class="line">reentrantLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;睡眠2秒...&quot;);</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">    System.out.println(&quot;reentrantLock-&gt;unlock&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现可定时的锁请求：tryLock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">    ReentrantLock reentrantLock &#x3D; new ReentrantLock();</span><br><span class="line">    Thread thread1 &#x3D; new Thread_tryLock(reentrantLock);</span><br><span class="line">    thread1.setName(&quot;thread1&quot;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    Thread thread2 &#x3D; new Thread_tryLock(reentrantLock);</span><br><span class="line">    thread2.setName(&quot;thread2&quot;);</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static class Thread_tryLock extends Thread &#123;</span><br><span class="line">    ReentrantLock reentrantLock;</span><br><span class="line"></span><br><span class="line">    public Thread_tryLock(ReentrantLock reentrantLock) &#123;</span><br><span class="line">        this.reentrantLock &#x3D; reentrantLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;try lock:&quot; + Thread.currentThread().getName());</span><br><span class="line">            boolean tryLock &#x3D; reentrantLock.tryLock(3, TimeUnit.SECONDS);</span><br><span class="line">            if (tryLock) &#123;</span><br><span class="line">                System.out.println(&quot;try lock success :&quot; + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(&quot;睡眠一下：&quot; + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                System.out.println(&quot;醒了：&quot; + Thread.currentThread().getName());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;try lock 超时 :&quot; + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;unlock:&quot; + Thread.currentThread().getName());</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Condition 条件</p></li></ul><p>Condition的 await 和 signal 使用，前提要先lock。</p><h4 id="3-4-公平锁与非公平锁"><a href="#3-4-公平锁与非公平锁" class="headerlink" title="3.4 公平锁与非公平锁"></a>3.4 公平锁与非公平锁</h4><p>ReentrantLock 构造函数传true表示公平锁。</p><p>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的顺序。而非公平锁就是一种锁的抢占机制，是随机获得锁的，可能会导致某些线程一致拿不到锁，所以是不公平的。</p><h4 id="3-5-ReentrantLock-注意点"><a href="#3-5-ReentrantLock-注意点" class="headerlink" title="3.5 ReentrantLock  注意点"></a>3.5 ReentrantLock  注意点</h4><ol><li>ReentrantLock使用lock和unlock来获得锁和释放锁</li><li>unlock要放在finally中，这样正常运行或者异常都会释放锁</li><li>使用condition的await和signal方法之前，必须调用lock方法获得对象监视器</li></ol><h3 id="4-并发包"><a href="#4-并发包" class="headerlink" title="4. 并发包"></a>4. 并发包</h3><p>解决在并发严重情况下，使用锁效率低下问题,以下为并发包常用数据结构</p><h4 id="4-1-ConcurrentHashMap"><a href="#4-1-ConcurrentHashMap" class="headerlink" title="4.1 ConcurrentHashMap"></a>4.1 ConcurrentHashMap</h4><p>ConcurrentHashMap 采用分段锁，内部默认有16个桶，get和put操作，首先将key计算hashcode，然后跟16取余，落到16个桶中的一个，然后每个桶中都加了锁（ReentrantLock），桶中是HashMap结构（数组加链表，链表过长转红黑树）。<br>所以理论上最多支持16个线程同时访问。</p><h4 id="4-2-LinkBlockingQueue"><a href="#4-2-LinkBlockingQueue" class="headerlink" title="4.2 LinkBlockingQueue"></a>4.2 LinkBlockingQueue</h4><ol><li>从队列获取数据，如果队列中没有数据，会调用notEmpty.await();进入等待。</li><li>在放数据进去队列的时候会调用notEmpty.signal();，通知消费者，1中的等待结束，唤醒继续执行。</li><li>从队列里取到数据的时候会调用notFull.signal();，通知生产者继续生产。</li><li>在put数据进入队列的时候，如果判断队列中的数据达到最大值，那么会调用notFull.await();，等待消费者消费掉，也就是等待3去取数据并且发出notFull.signal();，这时候生产者才能继续生产。</li></ol><p>LinkBlockingQueue 是典型的生产者消费者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        putLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-原子操作类：AtomicInteger"><a href="#4-3-原子操作类：AtomicInteger" class="headerlink" title="4.3 原子操作类：AtomicInteger"></a>4.3 原子操作类：AtomicInteger</h4><p>内部采用CAS（compare and swap）保证原子性</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol><li>当只有一个线程写，其它线程都是读的时候，可以用<code>volatile</code>修饰变量</li><li>当多个线程写，那么一般情况下并发不严重的话可以用<code>Synchronized</code>，<code>Synchronized</code>并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用<code>Synchronized</code>是可以的。不过<code>Synchronized</code>有局限性，比如不能设置锁超时，不能通过代码释放锁。</li><li><code>ReentranLock</code>可以通过代码释放锁，可以设置锁超时。</li><li>高并发下，<code>Synchronized</code>、<code>ReentranLock</code> 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如<code>ConcurrentHashMap</code>，<code>LinkBlockingQueue</code>，以及原子性的数据结构如：<code>AtomicInteger</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-并发问题产生的原因&quot;&gt;&lt;a href=&quot;#1-并发问题产生的原因&quot; class=&quot;headerlink&quot; title=&quot;1. 并发问题产生的原因&quot;&gt;&lt;/a&gt;1. 并发问题产生的原因&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程的工作内存中保存了该线程中用到的变量的主内存副本&lt;code&gt;拷贝&lt;/code&gt;，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。&lt;/li&gt;
&lt;li&gt;线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。&lt;/li&gt;
&lt;li&gt;不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java JVM(下）</title>
    <link href="http://yoursite.com/2020/07/27/Java-JVM%20%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/27/Java-JVM%20%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-07-27T09:57:30.000Z</published>
    <updated>2020-08-04T07:58:54.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-JVM性能调优"><a href="#1-JVM性能调优" class="headerlink" title="1. JVM性能调优"></a>1. JVM性能调优</h3><p>在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过 64 位 JDK 来使用大内存；</li><li>使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。<a id="more"></a><h4 id="1-1-通过-64-位-JDK-来使用大内存"><a href="#1-1-通过-64-位-JDK-来使用大内存" class="headerlink" title="1.1 通过 64 位 JDK 来使用大内存"></a>1.1 通过 64 位 JDK 来使用大内存</h4></li></ul><p>堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。</p><p>对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。</p><p>可能面临的问题：</p><ol><li>内存回收导致的长时间停顿；</li><li>现阶段，64位 JDK 的性能普遍比 32 位 JDK 低；</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析；</li><li>相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</li></ol><h4 id="1-2-使用-32-位-JVM-建立逻辑集群"><a href="#1-2-使用-32-位-JVM-建立逻辑集群" class="headerlink" title="1.2 使用 32 位 JVM 建立逻辑集群"></a>1.2 使用 32 位 JVM 建立逻辑集群</h4><p>在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</p><p>考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。</p><p>可能遇到的问题：</p><ol><li>尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常；</li><li>很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余；</li><li>各个节点受到 32 位的内存限制；</li><li>大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。</li></ol><h3 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2. 类加载机制"></a>2. 类加载机制</h3><h4 id="2-1-类生命周期"><a href="#2-1-类生命周期" class="headerlink" title="2.1 类生命周期"></a>2.1 类生命周期</h4><p><img src="/images/24.jpg" alt=""></p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是<code>开始</code>，而不是“进行”或“完成”），而解析阶段在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。</p><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ol><li>在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。</li><li>对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。</li><li>初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。</li><li>虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</li></ol><p>前面的五种方式是对一个类的<code>主动引用</code>，除此之外，所有引用类的方法都不会触发初始化，称为被动引用。</p><p>举几个例子~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">static</span> &#123;         </span><br><span class="line">            System.out.println(<span class="string">"SuperClass init!"</span>);     </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1127</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">static</span> &#123;        </span><br><span class="line">            System.out.println(<span class="string">"SubClass init!"</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;    </span><br><span class="line">         <span class="keyword">static</span> &#123;        </span><br><span class="line">            System.out.println(<span class="string">"ConstClass init!"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">            System.out.println(SubClass.value);        </span><br><span class="line">            <span class="comment">/**         </span></span><br><span class="line"><span class="comment">            *  output : SuperClass init!         </span></span><br><span class="line"><span class="comment">            *          </span></span><br><span class="line"><span class="comment">            * 通过子类引用父类的静态对象不会导致子类的初始化         </span></span><br><span class="line"><span class="comment">            * 只有直接定义这个字段的类才会被初始化         </span></span><br><span class="line"><span class="comment">            */</span>         </span><br><span class="line">            SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];        </span><br><span class="line">            <span class="comment">/**         </span></span><br><span class="line"><span class="comment">            *  output :          </span></span><br><span class="line"><span class="comment">            *          </span></span><br><span class="line"><span class="comment">            * 通过数组定义来引用类不会触发此类的初始化         </span></span><br><span class="line"><span class="comment">            * 虚拟机在运行时动态创建了一个数组类         </span></span><br><span class="line"><span class="comment">            */</span>         </span><br><span class="line">            System.out.println(ConstClass.HELLOWORLD);        </span><br><span class="line">            <span class="comment">/**         </span></span><br><span class="line"><span class="comment">            *  output :          </span></span><br><span class="line"><span class="comment">            *          </span></span><br><span class="line"><span class="comment">            * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，         </span></span><br><span class="line"><span class="comment">            * 因此不会触发定义常量的类的初始化。         </span></span><br><span class="line"><span class="comment">            * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。         </span></span><br><span class="line"><span class="comment">            */</span>    </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-类加载过程"><a href="#2-2-类加载过程" class="headerlink" title="2.2 类加载过程"></a>2.2 类加载过程</h4><p>类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。</p><h5 id="2-2-1-加载"><a href="#2-2-1-加载" class="headerlink" title="2.2.1 加载"></a>2.2.1 加载</h5><ol><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ol><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ol><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ol><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><h5 id="2-2-2-验证"><a href="#2-2-2-验证" class="headerlink" title="2.2.2 验证"></a>2.2.2 验证</h5><p>验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证的过程如下：</p><ol><li>文件格式验证<br> 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下： <ul><li>是否以魔数 0XCAFEBABE 开头</li><li>主次版本号是否在当前虚拟机处理范围内</li><li>常量池是否有不被支持的常量类型</li><li>指向常量的索引值是否指向了不存在的常量</li><li>CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据</li><li>……</li></ul></li><li>元数据验证<br> 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。</li><li>字节码验证<br> 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</li><li>符号引用验证<br> 本阶段发生在解析阶段，确保解析正常执行。</li></ol><h5 id="2-2-3-准备"><a href="#2-2-3-准备" class="headerlink" title="2.2.3 准备"></a>2.2.3 准备</h5><p>准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。</p><p>初始值“通常情况下”是数据类型的零值（0, null…），假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。</p><p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。</p><h5 id="2-2-4-解析"><a href="#2-2-4-解析" class="headerlink" title="2.2.4 解析"></a>2.2.4 解析</h5><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h5 id="2-2-5-初始化"><a href="#2-2-5-初始化" class="headerlink" title="2.2.5 初始化"></a>2.2.5 初始化</h5><p>类初始化阶段是类加载过程的最后一步，是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法。</p><h4 id="2-3-接口加载过程"><a href="#2-3-接口加载过程" class="headerlink" title="2.3 接口加载过程"></a>2.3 接口加载过程</h4><p>接口加载过程与类加载过程稍有不同。<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p><h4 id="2-4-类加载器"><a href="#2-4-类加载器" class="headerlink" title="2.4 类加载器"></a>2.4 类加载器</h4><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p><h5 id="2-4-1-加载器的种类（3种"><a href="#2-4-1-加载器的种类（3种" class="headerlink" title="2.4.1 加载器的种类（3种)"></a>2.4.1 加载器的种类（3种)</h5><ul><li>启动类加载器（Bootstrap ClassLoader）:<br>  加载存放在 <JAVA_HOME>\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别的类，如 rt.jar。</li><li>扩展类加载器（Extension ClassLoader）：<br>  加载 <JAVA_HOME>\lib\ext 目录中的所有类库。</li><li>应用程序类加载器（Application ClassLoader）：<br>  ClassLoader 负责，加载用户类路径（classpath）上所指定的类库。</li></ul><h5 id="2-4-2-双亲委派模型"><a href="#2-4-2-双亲委派模型" class="headerlink" title="2.4.2 双亲委派模型"></a>2.4.2 双亲委派模型</h5><p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）</p><ul><li>工作过程<br>  如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</li></ul><p>在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程。</p><ul><li><p>使用该模型的原因</p><p>  像 java.lang.Object 这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。</p><p>  相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-JVM性能调优&quot;&gt;&lt;a href=&quot;#1-JVM性能调优&quot; class=&quot;headerlink&quot; title=&quot;1. JVM性能调优&quot;&gt;&lt;/a&gt;1. JVM性能调优&lt;/h3&gt;&lt;p&gt;在高性能硬件上部署程序，目前主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 64 位 JDK 来使用大内存；&lt;/li&gt;
&lt;li&gt;使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java JVM(上)</title>
    <link href="http://yoursite.com/2020/07/26/Java-JVM%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/26/Java-JVM%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-07-26T07:19:39.000Z</published>
    <updated>2020-07-26T09:49:55.952Z</updated>
    
    <content type="html"><![CDATA[<p>JVM是Java Virtual Machine（Java虚拟机）的缩写。Java虚拟机为程序虚拟机，它专门为执行单个计算机程序而设计。在Java虚拟机中执行的指令我们称为Java字节码指令。（JVM是运行在操作系统之上的，它与硬件没有直接的交互）,java虚拟机就在jre的文件夹里面。</p><a id="more"></a><h3 id="1-JVM内存模型"><a href="#1-JVM内存模型" class="headerlink" title="1. JVM内存模型"></a>1. JVM内存模型</h3><p><img src="/images/20.jpg" alt=""></p><p>每个区域存储的内容<br><img src="/images/21.jpg" alt=""></p><ol><li><p>程序计数器：<br> 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。它是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</p></li><li><p>Java 虚拟机栈:<br> 线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p><p> 局部变量表：存放了编译期可知的8大基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p> 会出现以下2种异常：<br> StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p></li><li><p>本地方法栈<br> 区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p></li><li><p>Java堆<br> 是 JVM 所管理的内存中最大的一块。线程共享，整个 Java 虚拟机只有一个堆，主要是存放对象实例和数组。是垃圾回收的主要场所，内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上<code>不连续</code>的空间，但是逻辑上要连续。<br> OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p></li><li><p>方法区<br> 方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。</p></li><li><p>直接内存（堆外内存）<br> 非虚拟机运行时数据区的部分<br> 在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。直接内存的大小不受 Java 虚拟机控制，当内存不足时就会抛出 OutOfMemoryError 异常。</p></li></ol><h3 id="2-HotSpot-虚拟机对象探秘"><a href="#2-HotSpot-虚拟机对象探秘" class="headerlink" title="2.HotSpot 虚拟机对象探秘"></a>2.HotSpot 虚拟机对象探秘</h3><h4 id="2-1-对象创建"><a href="#2-1-对象创建" class="headerlink" title="2.1 对象创建"></a>2.1 对象创建</h4><ol><li>类加载检查：虚拟机在解析.class文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</li><li>为新对象分配内存：(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</li><li>初始化：为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</li></ol><h4 id="2-2-对象内存布局"><a href="#2-2-对象内存布局" class="headerlink" title="2.2 对象内存布局"></a>2.2 对象内存布局</h4><ol><li>对象头（Header）：<br> 对象头记录了对象在运行过程中所需要使用的一些数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳<br> 对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。</li><li>实例数据（Instance Data）：<br> 成员变量的值，其中包括父类继承下来的和子类中定义的。</li><li>对齐填充（Padding）：<br> 不是必然需要，主要是占位，保证对象大小是8字节的整数倍。</li></ol><h4 id="2-3-对象访问方式"><a href="#2-3-对象访问方式" class="headerlink" title="2.3 对象访问方式"></a>2.3 对象访问方式</h4><ul><li><p>句柄访问方式<br>  访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。<br>  <img src="/images/22.jpg" alt=""></p></li><li><p>直接指针访问<br>  通过引用能够直接访问对象。但对象所在的内存空间需要<code>额外的策略</code>存储对象所属的类信息的地址。<br>  <img src="/images/23.jpg" alt=""></p></li></ul><p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><h4 id="2-4-HotSpot-垃圾收集器"><a href="#2-4-HotSpot-垃圾收集器" class="headerlink" title="2.4 HotSpot 垃圾收集器"></a>2.4 HotSpot 垃圾收集器</h4><p>新生代：</p><ul><li>Serial 垃圾收集器（单线程）：只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</li><li>ParNew 收集器（多线程）：可以认为是 Serial 收集器的多线程版本。追求降低用户停顿时间，适合交互式应用。</li><li>Parallel Scavenge 垃圾收集器（多线程）：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。</li></ul><p>老年代：</p><ul><li>Serial Old 收集器（单线程）：使用 “标记 —— 整理”算法。</li><li>Parallel Old 收集器（多线程）：是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。</li><li>CMS 垃圾收集器：以获取最短回收停顿时间为目标，缺点是对 CPU 资源敏感、无法收集浮动垃圾、“标记 —— 清除”算法带来的空间碎片</li><li>G1 收集器：面向服务端的垃圾回收器。优点：并行与并发、分代收集、空间整合、可预测停顿。</li></ul><h3 id="3-GC垃圾回收"><a href="#3-GC垃圾回收" class="headerlink" title="3. GC垃圾回收"></a>3. GC垃圾回收</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>程序计数器、虚拟机栈、本地方法栈、栈帧 随着方法结束或者线程结束时，内存自然跟着回收。<br>对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，垃圾收集器所关注的正是这部分内存。</p><h4 id="3-2-判断对象的存活"><a href="#3-2-判断对象的存活" class="headerlink" title="3.2 判断对象的存活"></a>3.2 判断对象的存活</h4><p>若一个对象不被任何对象或变量引用，那么它就是无效，需被回收。</p><ul><li><p>引用计数法<br>  在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。<br>  实现简单，判定效率高，但难以解决对象的循环引用。<br>  例子：objA.instance = objB 且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。</p></li><li><p>可达性分析法<br>所有和 GC Roots 直接或间接关联的对象为有效对象，和 GC Roots 无关的为无效对象。</p></li></ul><p>GC Roots 是指：<br>    1. Java 虚拟机栈（栈帧中的本地变量表）中引用的对象<br>    2. 本地方法栈中引用的对象<br>    3. 方法区中常量引用的对象<br>    4. 方法区中类静态属性引用的对象</p><p>GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</p><h4 id="3-3-引用种类（强到弱）"><a href="#3-3-引用种类（强到弱）" class="headerlink" title="3.3 引用种类（强到弱）"></a>3.3 引用种类（强到弱）</h4><ul><li>强引用（Strong Reference）<br>  类似于 Object obj = new Object(); 只要强引用在就不回收。</li><li>软引用（Soft Reference）<br>  SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li><li>弱引用（Weak Reference）<br>  当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。</li><li>虚引用（Phantom Reference）<br>  无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="3-4-回收堆中无效对象"><a href="#3-4-回收堆中无效对象" class="headerlink" title="3.4 回收堆中无效对象"></a>3.4 回收堆中无效对象</h4><ul><li>判定 finalize() 是否有必要执行<br>如果对象没有覆盖 finalize() 方法，或该方法已被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。</li></ul><p>若对象被判定为有必要执行 finalize() 方法，对象会被放入一个 <code>F-Queue</code>队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。</p><ul><li>对象重生或死亡<br>如果在执行 finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</li></ul><p><code>tip:</code>finalize() 方法只会被系统自动调用一次。</p><h4 id="3-5-回收方法区内存"><a href="#3-5-回收方法区内存" class="headerlink" title="3.5 回收方法区内存"></a>3.5 回收方法区内存</h4><p>主要清除废弃的常量和无用的类。</p><p>判断废弃常量：一般是判断没有该常量的引用。<br>判断无用的类：要以下三个条件都满足<br>    1. 该类所有的实例都已经回收<br>    2. 加载该类的 ClassLoader 已经被回收<br>    3. 该类对应的 java.lang.Class 对象没在任何地方被引用，无法在任何地方通过反射访问该类的方法</p><h4 id="3-6-垃圾收集算法"><a href="#3-6-垃圾收集算法" class="headerlink" title="3.6 垃圾收集算法"></a>3.6 垃圾收集算法</h4><p>常见的垃圾收集算法有：标记-清除算法，复制算法（新生代），标记-整理算法（老年代），分代收集算法</p><h3 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4. 内存分配与回收策略"></a>4. 内存分配与回收策略</h3><ul><li><p>对象优先在 Eden 分配<br>  对象主要分配在新生代的 Eden 区上，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><ol><li>Minor GC：发生在新生代的垃圾回收动作，频繁，速度快。</li><li>Major GC / Full GC: 回收老年代，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</li></ol></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活的对象将进入老年代</p></li><li><p>动态对象年龄判定</p></li><li><p>空间分配担保</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写。Java虚拟机为程序虚拟机，它专门为执行单个计算机程序而设计。在Java虚拟机中执行的指令我们称为Java字节码指令。（JVM是运行在操作系统之上的，它与硬件没有直接的交互）,java虚拟机就在jre的文件夹里面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://yoursite.com/2020/07/21/Java%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/21/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2020-07-21T06:18:53.000Z</published>
    <updated>2020-07-21T07:04:57.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、反射概念"><a href="#1、反射概念" class="headerlink" title="1、反射概念"></a>1、反射概念</h3><ul><li>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</li><li>使用前提：先要获取到每一个字节码文件对应的Class类型的对象。</li></ul><a id="more"></a><h3 id="2、反射主要提供的功能"><a href="#2、反射主要提供的功能" class="headerlink" title="2、反射主要提供的功能"></a>2、反射主要提供的功能</h3><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；<br>总之就是通过反射机制访问java对象的属性，方法，构造方法等；</li></ol><h3 id="3、反射机制中的类"><a href="#3、反射机制中的类" class="headerlink" title="3、反射机制中的类"></a>3、反射机制中的类</h3><ol><li>java.lang.Class;                </li><li>java.lang.reflect.Constructor; java.lang.reflect.Field;        </li><li>java.lang.reflect.Method;</li><li>java.lang.reflect.Modifier;<br>很多反射中的方法，属性等操作我们可以从这四个类中查询。去查询API学习使用</li></ol><h3 id="4、反射的使用"><a href="#4、反射的使用" class="headerlink" title="4、反射的使用"></a>4、反射的使用</h3><h4 id="4、1-反射机制获取类-3种"><a href="#4、1-反射机制获取类-3种" class="headerlink" title="4、1 反射机制获取类(3种)"></a>4、1 反射机制获取类(3种)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：</span></span><br><span class="line">    Classc1 = Class.forName(<span class="string">"Employee"</span>);</span><br><span class="line"><span class="comment">//第二种方式：</span></span><br><span class="line"><span class="comment">//java中每个类型都有class属性</span></span><br><span class="line">    Classc2 = Employee<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//第三种方式：</span></span><br><span class="line"><span class="comment">//java语言中任何一个java对象都有getClass 方法</span></span><br><span class="line">    Employee e= <span class="keyword">new</span> Employee();</span><br><span class="line">    Class c3= e.getClass(); <span class="comment">//c3是运行时类 (e的运行时类是Employee)</span></span><br></pre></td></tr></table></figure><h4 id="4、2-创建对象"><a href="#4、2-创建对象" class="headerlink" title="4、2 创建对象"></a>4、2 创建对象</h4><p>获取类以后我们来创建它的对象，利用<code>newInstance</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Class c =Class.forName(<span class="string">"Employee"</span>);</span><br><span class="line"><span class="comment">//创建此Class 对象所表示的类的一个新实例</span></span><br><span class="line"> Objec to = c.newInstance(); <span class="comment">//调用了Employee的无参数构造方法.</span></span><br></pre></td></tr></table></figure><h4 id="4、3-获取属性"><a href="#4、3-获取属性" class="headerlink" title="4、3 获取属性"></a>4、3 获取属性</h4><ul><li><p>获取所有属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取整个类</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.lang.Integer"</span>);      </span><br><span class="line"><span class="comment">//获取所有的属性</span></span><br><span class="line">Field[] fs = c.getDeclaredFields();                </span><br><span class="line"><span class="comment">//定义可变长的字符串，用来存储属性</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();        </span><br><span class="line"><span class="comment">//通过追加的方法，将每个属性拼接到此字符串中</span></span><br><span class="line"><span class="comment">//最外边的public定义</span></span><br><span class="line">sb.append(Modifier.toString(c.getModifiers()) + <span class="string">" class "</span> + c.getSimpleName() +<span class="string">"&#123;\n"</span>);        </span><br><span class="line"><span class="comment">//里边的每一个属性</span></span><br><span class="line"><span class="keyword">for</span>(Field field:fs)&#123;</span><br><span class="line">    sb.append(<span class="string">"\t"</span>);<span class="comment">//空格</span></span><br><span class="line">    sb.append(Modifier.toString(field.getModifiers())+<span class="string">" "</span>);<span class="comment">//获得属性的修饰符，例如public，static等等</span></span><br><span class="line">    sb.append(field.getType().getSimpleName() + <span class="string">" "</span>);<span class="comment">//属性的类型的名字</span></span><br><span class="line">    sb.append(field.getName()+<span class="string">";\n"</span>);<span class="comment">//属性的名字+回车</span></span><br><span class="line">&#125;</span><br><span class="line">    sb.append(<span class="string">"&#125;"</span>);</span><br><span class="line">    System.out.println(sb);</span><br></pre></td></tr></table></figure></li><li><p>获取特定的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//以前的方式：</span></span><br><span class="line">    <span class="comment">/*User u = new User();</span></span><br><span class="line"><span class="comment">        u.age = 12; //set</span></span><br><span class="line"><span class="comment">        System.out.println(u.age); //get</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//获取类</span></span><br><span class="line">    Class c = Class.forName(<span class="string">"User"</span>);</span><br><span class="line">    <span class="comment">//获取id属性</span></span><br><span class="line">    Field idF = c.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">    <span class="comment">//实例化这个类赋给o</span></span><br><span class="line">    Object o = c.newInstance();</span><br><span class="line">    <span class="comment">//打破封装</span></span><br><span class="line">    idF.setAccessible(<span class="keyword">true</span>); </span><br><span class="line">    <span class="comment">//使用反射机制可以打破封装性，导致了java对象的属性不安全。</span></span><br><span class="line">    <span class="comment">//给o对象的id属性赋值"110"</span></span><br><span class="line">    idF.set(o, <span class="string">"110"</span>); <span class="comment">//set</span></span><br><span class="line">    <span class="comment">//get</span></span><br><span class="line">    System.out.println(idF.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、4-获取方法、构造方法关键字"><a href="#4、4-获取方法、构造方法关键字" class="headerlink" title="4、4 获取方法、构造方法关键字"></a>4、4 获取方法、构造方法关键字</h4><table><thead><tr><th>方法关键字</th><th>含义</th></tr></thead><tbody><tr><td>getDeclaredMethods()</td><td>获取所有的方法</td></tr><tr><td>getReturnType()</td><td>获得方法的放回类型</td></tr><tr><td>getParameterTypes()</td><td>获得方法的传入参数类型</td></tr><tr><td>getDeclaredMethod(“方法名”,参数类型.class,……)</td><td>获得特定的方法</td></tr></tbody></table><table><thead><tr><th>构造方法关键字</th><th>含义</th></tr></thead><tbody><tr><td>getDeclaredConstructors()</td><td>获取所有的构造方法</td></tr><tr><td>getDeclaredConstructor(参数类型.class,……)</td><td>获取特定的构造方法</td></tr></tbody></table><table><thead><tr><th>父类和父接口</th><th>含义</th></tr></thead><tbody><tr><td>getSuperclass()</td><td>获取某类的父类</td></tr><tr><td>getInterfaces()</td><td>获取某类实现的接口</td></tr></tbody></table><ul><li>这样我们就可以获得类的各种内容，进行了反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。</li></ul><h3 id="5、反射优缺点"><a href="#5、反射优缺点" class="headerlink" title="5、反射优缺点"></a>5、反射优缺点</h3><p>优点： </p><ol><li>能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。 </li><li>与Java动态编译相结合，可以实现无比强大的功能 </li></ol><p>缺点： </p><ol><li>使用反射的性能较低 </li><li>使用反射相对来说不安全 </li><li>破坏了类的封装性，可以通过反射获取这个类的私有方法和属性 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、反射概念&quot;&gt;&lt;a href=&quot;#1、反射概念&quot; class=&quot;headerlink&quot; title=&quot;1、反射概念&quot;&gt;&lt;/a&gt;1、反射概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。&lt;/li&gt;
&lt;li&gt;使用前提：先要获取到每一个字节码文件对应的Class类型的对象。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="http://yoursite.com/2020/07/19/Java-IO/"/>
    <id>http://yoursite.com/2020/07/19/Java-IO/</id>
    <published>2020-07-19T08:28:04.000Z</published>
    <updated>2020-07-19T09:08:01.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、流的概念和作用"><a href="#1、流的概念和作用" class="headerlink" title="1、流的概念和作用"></a>1、流的概念和作用</h3><ul><li>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</li><li>作用：为数据源和目的地建立一个输送通道。<a id="more"></a><h3 id="2、I-O流常见类"><a href="#2、I-O流常见类" class="headerlink" title="2、I/O流常见类"></a>2、I/O流常见类</h3></li></ul><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>File</td><td>文件类，用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</td></tr><tr><td>InputStream</td><td><code>字节</code>输入流，抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</td></tr><tr><td>OutputStream</td><td><code>字节</code>输入流，抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</td></tr><tr><td>Reader</td><td><code>字符</code>输入流，抽象类，基于字符的输入操作。</td></tr><tr><td>Writer</td><td><code>字符</code>输出流，抽象类，基于字符的输出操作。</td></tr><tr><td>RandomAccessFile</td><td>随机存取文件类，一个独立的类，直接继承至Object.它的功能丰富，可以从文件的<code>任意</code>位置进行存取（输入输出）操作。注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。</td></tr></tbody></table><p>Java流类的类结构图<br><img src="/images/19.jpg" alt=""></p><ul><li>字节流：数据流中最小的数据单元是字节</li><li>字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</li></ul><h3 id="3、流的特性"><a href="#3、流的特性" class="headerlink" title="3、流的特性"></a>3、流的特性</h3><ul><li>先进先出，最先写入输出流的数据最先被输入流读取到。</li><li>顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile可以从文件的任意位置进行存取（输入输出）操作）</li><li>只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。 </li></ul><h3 id="4、Java-IO流对象"><a href="#4、Java-IO流对象" class="headerlink" title="4、Java IO流对象"></a>4、Java IO流对象</h3><h4 id="4-1-输入字节流InputStream"><a href="#4-1-输入字节流InputStream" class="headerlink" title="4.1 输入字节流InputStream"></a>4.1 输入字节流InputStream</h4><ul><li>InputStream中的三个基本的读方法：</li></ul><ol><li>abstract int read() ：读取一个字节数据，并返回读到的数据，如果返回-1，表示读到了输入流的末尾。</li><li>intread(byte[]?b) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。</li><li>intread(byte[]?b, int?off, int?len) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。off指定在数组b中存放数据的起始偏移位置；len指定读取的最大字节数。</li></ol><p>流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时。</p><ul><li>其他方法</li></ul><ol><li>long skip(long?n)：在输入流中跳过n个字节，并返回实际跳过的字节数。</li><li>int available() ：返回在不发生阻塞的情况下，可读取的字节数。</li><li>void close() ：关闭输入流，释放和这个流相关的系统资源。</li><li>voidmark(int?readlimit) ：在输入流的当前位置放置一个标记，如果读取的字节数多于readlimit设置的值，则流忽略这个标记。</li><li>void reset() ：返回到上一个标记。</li><li>booleanmarkSupported() ：测试当前流是否支持mark和reset方法。如果支持，返回true，否则返回false。</li></ol><h4 id="4-2-输出字节流OutputStream"><a href="#4-2-输出字节流OutputStream" class="headerlink" title="4.2 输出字节流OutputStream"></a>4.2 输出字节流OutputStream</h4><ul><li>outputStream中的三个基本的写方法   </li></ul><ol><li>abstract void write(int?b)：往输出流中写入一个字节。</li><li>void write(byte[]?b) ：往输出流中写入数组b中的所有字节。</li><li>void write(byte[]?b, int?off, int?len) ：往输出流中写入数组b中从偏移量off开始的len个字节的数据。</li></ol><ul><li>其它方法</li></ul><ol><li>void flush() ：刷新输出流，强制缓冲区中的输出字节被写出。</li><li>void close() ：关闭输出流，释放和这个流相关的系统资源。</li></ol><h4 id="4-3-字符输入流Reader"><a href="#4-3-字符输入流Reader" class="headerlink" title="4.3 字符输入流Reader"></a>4.3 字符输入流Reader</h4><ul><li>主要方法：</li></ul><ol><li>public int read() throws IOException; //读取一个字符，返回值为读取的字符 </li><li>public int read(char cbuf[]) throws IOException; /<em>读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</em>/ </li><li>public abstract int read(char cbuf[],int off,int len) throws IOException; /<em>读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</em>/ </li></ol><h4 id="4-4-字符输出流Writer"><a href="#4-4-字符输出流Writer" class="headerlink" title="4.4 字符输出流Writer"></a>4.4 字符输出流Writer</h4><ul><li>主要方法：</li></ul><ol><li>public void write(int c) throws IOException； //将整型值c的低16位写入输出流 </li><li>public void write(char cbuf[]) throws IOException； //将字符数组cbuf[]写入输出流 </li><li>public abstract void write(char cbuf[],int off,int len) throws IOException； //将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流 </li><li>public void write(String str) throws IOException； //将字符串str中的字符写入输出流 </li><li>public void write(String str,int off,int len) throws IOException； //将字符串str 中从索引off开始处的len个字符写入输出流 </li></ol><h3 id="5、转换流"><a href="#5、转换流" class="headerlink" title="5、转换流"></a>5、转换流</h3><ul><li>特点：</li></ul><ol><li>其是字符流和字节流之间的桥梁</li><li>可对读取到的字节数据经过指定编码转换成字符</li><li>可对读取到的字符数据经过指定编码转换成字节</li></ol><ul><li>具体对象体现：</li></ul><ol><li>InputStreamReader:字节到字符的桥梁</li><li>OutputStreamWriter:字符到字节的桥梁</li><li>OutputStreamWriter(OutStreamout):将字节流以字符流输出。</li><li>InputStreamReader(InputStream in)：将字节流以字符流输入。</li></ol><h3 id="6、字节流与字符流的区别"><a href="#6、字节流与字符流的区别" class="headerlink" title="6、字节流与字符流的区别"></a>6、字节流与字符流的区别</h3><ul><li><p>节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。</p></li><li><p>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p></li><li><p>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p></li><li><p>结论：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。</p></li></ul><h3 id="7、File类"><a href="#7、File类" class="headerlink" title="7、File类"></a>7、File类</h3><ul><li><p>File类是Object的直接子类，同时它继承了Comparable接口可以进行数组的排序。File类的操作包括文件的创建、删除、重命名、得到路径、创建时间等。</p></li><li><p>构造函数：</p></li></ul><ol><li>File (String   pathname)   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File  f1=<span class="keyword">new</span> File(<span class="string">"FileTest1.txt"</span>); <span class="comment">//创建文件对象f1，f1所指的文件是在当前目录下创建的FileTest1.txt</span></span><br></pre></td></tr></table></figure></li><li>File (String  parent  ,  String child)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File f2=<span class="keyword">new</span>  File(<span class="string">"D:\\dir1"</span>,<span class="string">"FileTest2.txt"</span>); <span class="comment">// 注意：D:\\dir1目录事先必须存在，否则异常</span></span><br></pre></td></tr></table></figure></li><li>File (File parent,String child)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File  f4=<span class="keyword">new</span> File(<span class="string">"\\dir3"</span>);</span><br><span class="line">File  f5=<span class="keyword">new</span> File(f4,<span class="string">"FileTest5.txt"</span>); <span class="comment">//在如果 \\dir3目录不存在使用f4.mkdir()先创建</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>一个对应于某磁盘文件或目录的File对象一经创建， 就可以通过调用它的方法来获得文件或目录的属性。    </li></ul><ol><li>public boolean exists( ) 判断文件或目录是否存在</li><li>public boolean isFile( ) 判断是文件还是目录 </li><li>public boolean isDirectory( ) 判断是文件还是目录</li><li>public String getName( ) 返回文件名或目录名</li><li>public String getPath( ) 返回文件或目录的路径。</li><li>public long length( ) 获取文件的长度 </li><li>public String[ ] list ( ) 将目录中所有文件名保存在字符串数组中返回。 </li></ol><ul><li>File类中还定义了一些对文件或目录进行管理、操作的方法，常用的方法有：</li></ul><ol><li>public boolean renameTo( File newFile );    重命名文件</li><li>public void delete( );   删除文件</li><li>public boolean mkdir( ); 创建目录</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、流的概念和作用&quot;&gt;&lt;a href=&quot;#1、流的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;1、流的概念和作用&quot;&gt;&lt;/a&gt;1、流的概念和作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。&lt;/li&gt;
&lt;li&gt;作用：为数据源和目的地建立一个输送通道。
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别</title>
    <link href="http://yoursite.com/2020/07/19/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/07/19/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-07-19T02:19:42.000Z</published>
    <updated>2020-07-19T09:05:52.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、运行速度"><a href="#1、运行速度" class="headerlink" title="1、运行速度"></a>1、运行速度</h3><ul><li>快到慢<br>StringBuilder &gt; StringBuffer &gt; String</li><li>此排序原因<br>String为字符串常量，即String对象一旦创建不可更改，而其他2个为字符串变量，是可以更改的。<a id="more"></a>例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abcd"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str=str+<span class="string">"ef;</span></span><br><span class="line"><span class="string">System.out.println(str);</span></span><br></pre></td></tr></table></figure></li><li>JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</li><li>而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</li></ul><h3 id="2、线程安全"><a href="#2、线程安全" class="headerlink" title="2、线程安全"></a>2、线程安全</h3><ul><li>StringBuilder是线程不安全的，而StringBuffer是线程安全的<br>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时StringBuffer中很多方法可以带有<code>synchronized</code>关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3></li><li>String：适用于少量的字符串操作的情况</li><li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</li><li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、运行速度&quot;&gt;&lt;a href=&quot;#1、运行速度&quot; class=&quot;headerlink&quot; title=&quot;1、运行速度&quot;&gt;&lt;/a&gt;1、运行速度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;快到慢&lt;br&gt;StringBuilder &amp;gt; StringBuffer &amp;gt; String&lt;/li&gt;
&lt;li&gt;此排序原因&lt;br&gt;String为字符串常量，即String对象一旦创建不可更改，而其他2个为字符串变量，是可以更改的。
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Java MySQL连接</title>
    <link href="http://yoursite.com/2020/07/18/Java-MySQL%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2020/07/18/Java-MySQL%E8%BF%9E%E6%8E%A5/</id>
    <published>2020-07-18T09:43:04.000Z</published>
    <updated>2020-07-18T09:54:19.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、导入jar包"><a href="#1、导入jar包" class="headerlink" title="1、导入jar包"></a>1、导入jar包</h3><p>Java连接MySQL需要驱动包，可去网上下载相应的jar包，导入到所需的项目。<br>这里在IDEA导入8.0版本以上的包</p><a id="more"></a><p><img src="/images/18.jpg" alt=""></p><h3 id="2、在项目中加载，不同版本连接数据库有所不同"><a href="#2、在项目中加载，不同版本连接数据库有所不同" class="headerlink" title="2、在项目中加载，不同版本连接数据库有所不同"></a>2、在项目中加载，不同版本连接数据库有所不同</h3><ul><li>MySQL 8.0 以上版本驱动包版本 mysql-connector-java-8.0.16.jar。</li><li>com.mysql.jdbc.Driver 更换为 com.mysql.cj.jdbc.Driver。</li><li>MySQL 8.0 以上版本不需要建立 SSL 连接的，需要显示关闭。</li><li>allowPublicKeyRetrieval=true 允许客户端从服务器获取公钥。</li><li>最后还需要设置 CST。<h3 id="3、创建测试数据库"><a href="#3、创建测试数据库" class="headerlink" title="3、创建测试数据库"></a>3、创建测试数据库</h3>这边建立store数据库。建立customer表<br><img src="/images/16.jpg" alt=""><h3 id="4、代码测试连接"><a href="#4、代码测试连接" class="headerlink" title="4、代码测试连接"></a>4、代码测试连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line"><span class="comment">//    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";</span></span><br><span class="line"><span class="comment">//    static final String DB_URL = "jdbc:mysql://localhost:3306/store";</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/store?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            System.out.println(<span class="string">"连接数据库..."</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            System.out.println(<span class="string">" 实例化Statement对象..."</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">"SELECT id, name, phone FROM customers"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                String id  = rs.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                String phone = rs.getString(<span class="string">"phone"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">                System.out.print(<span class="string">", 名字: "</span> + name);</span><br><span class="line">                System.out.print(<span class="string">", 电话号码 : "</span> + phone);</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;<span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试结果如下<br><img src="/images/17.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、导入jar包&quot;&gt;&lt;a href=&quot;#1、导入jar包&quot; class=&quot;headerlink&quot; title=&quot;1、导入jar包&quot;&gt;&lt;/a&gt;1、导入jar包&lt;/h3&gt;&lt;p&gt;Java连接MySQL需要驱动包，可去网上下载相应的jar包，导入到所需的项目。&lt;br&gt;这里在IDEA导入8.0版本以上的包&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="MySQL连接" scheme="http://yoursite.com/tags/MySQL%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java常用容器</title>
    <link href="http://yoursite.com/2020/07/16/Java%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/16/Java%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/</id>
    <published>2020-07-16T03:08:40.000Z</published>
    <updated>2020-07-16T04:19:12.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-容器的概念"><a href="#1、-容器的概念" class="headerlink" title="1、 容器的概念"></a>1、 容器的概念</h3><p>在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。</p><a id="more"></a><table><thead><tr><th>接口</th><th>Collection</th><th>Collection</th><th>Collection</th><th>Collection</th><th>Map</th></tr></thead><tbody><tr><td>-</td><td>Set[集] 不重复</td><td>Set[集] 不重复</td><td>List[列表] 可重复</td><td>List[列表] 可重复</td><td>不重复</td></tr><tr><td>实现类</td><td>HashSet</td><td>TreeSet</td><td>LinkedList</td><td>ArrayList</td><td>HashMap</td></tr><tr><td>内部存储结构</td><td>哈希表</td><td>树</td><td>链表</td><td>数组</td><td>哈希表</td></tr><tr><td>是否有序</td><td>无序</td><td>默认升序</td><td>有序</td><td>有序</td><td>无序</td></tr><tr><td>代码补充:自定义类</td><td>hashcode equals</td><td>comparabl e(必须)</td><td>比较时需实现 comparable接口</td><td>比较时需实现 comparable接口</td><td>hashcode equals</td></tr></tbody></table><h3 id="2、-容器和数组的关系"><a href="#2、-容器和数组的关系" class="headerlink" title="2、 容器和数组的关系"></a>2、 容器和数组的关系</h3><ul><li>数组的长度难以扩充</li><li>数组中数据的类型必须相同</li><li>容器不是数组，不能通过下标的方式访问容器中的元素</li><li>数组的所有功能通过<code>Arraylist</code>容器都可以实现，只是实现的方式不同</li><li>如果非要将容器当做一个数组来使用，通过toArray方法返回的就是一个数组<br>示例程序：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        arrayList.add(<span class="number">12</span>);</span><br><span class="line">        arrayList.add(<span class="number">10</span>);</span><br><span class="line">        arrayList.add(<span class="number">35</span>);</span><br><span class="line">        arrayList.add(<span class="number">100</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = arrayList.iterator();<span class="comment">//获取容器的迭代器</span></span><br><span class="line">        System.out.print(<span class="string">"通过迭代器获取： "</span>);</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Integer value = iterator.next();<span class="comment">//获取当前游标右边的元素，同时游标右移</span></span><br><span class="line">            System.out.print(value+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\n通过ArrayList获取： "</span>);</span><br><span class="line">        Object[] arr = arrayList.toArray();</span><br><span class="line">        <span class="keyword">for</span>(Object i:arr)&#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            System.out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果：<br><img src="/images/14.jpg" alt=""></li></ul><h3 id="3、容器常用的方法"><a href="#3、容器常用的方法" class="headerlink" title="3、容器常用的方法"></a>3、容器常用的方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean add(Object obj)</td><td>向容器中添加指定的元素</td></tr><tr><td>Iterator iterator（）</td><td>返回能够遍历当前集合中所有元素的迭代器</td></tr><tr><td>Object[] toArray()</td><td>返回包含此容器中所有元素的数组。</td></tr><tr><td>Object get（int index）</td><td>获取下标为index的那个元素</td></tr><tr><td>Object remove（int index）</td><td>删除下标为index的那个元素</td></tr><tr><td>Object set（int index,Object element）</td><td>将下标为index的那个元素置为element</td></tr><tr><td>Object add（int index,Object element）</td><td>在下标为index的位置添加一个对象element</td></tr><tr><td>Object put(Object key,Object value)</td><td>向容器中添加指定的元素</td></tr><tr><td>Object get（Object key）</td><td>获取关键字为key的那个对象</td></tr><tr><td>int size()</td><td>返回容器中的元素数</td></tr></tbody></table><p><code>tip:</code>Object put(Object key,Object value)</p><ul><li>根据key计算存储位置，若该位置原来已有元素，则覆盖</li><li>该方法返回覆盖前元素对象的值，若原本为空，则返回null</li></ul><h4 id="3-1-HashSet-VS-TreeSet"><a href="#3-1-HashSet-VS-TreeSet" class="headerlink" title="3.1 HashSet  VS  TreeSet"></a>3.1 HashSet  VS  TreeSet</h4><ul><li>HashSet是基于Hash算法实现，其性能通常优于TreeSet。我们通常应该使用HashSet,在需要功能时，才去使用TreeSet。<br><code>tips：</code></li></ul><ol><li>对于Set和Map来说，元素放进去是无顺序的，若需有顺序可以用TreeSet和TreeMap存储数据。</li><li>toString()方法的使用：凡是把类对象放到容器中，相应的类都应该实现Object类中的toString()方法；凡是Java中自带的数据类型，都已经重写完了toString()方法。</li><li>Comparable接口中的compareTo()方法:凡是需要进行比较排序的类都应该实现Comparable接口中的compareTo()方法；凡是把类对象放到以树为内部结构的容器中都应该实现Comparable接口中的compareTo()方法。</li><li>凡是把类对象放到以哈希表为内部存储结构的容器中，相应的类必须要实现equals方法和hashCode方法，这样才符合哈希表真实的逻辑功能.（对于自己定义的类，如果你没有重写hashcode方法，我们可以通过hashcode方法获取该对象的内存地址）</li></ol><h4 id="3-2-LinkedList-VS-ArrayList"><a href="#3-2-LinkedList-VS-ArrayList" class="headerlink" title="3.2 LinkedList  VS  ArrayList"></a>3.2 LinkedList  VS  ArrayList</h4><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。<br>与 ArrayList 相比，LinkedList 的<code>增删</code>效率更高，而ArrayList <code>改查</code>效率更高<br>以下情况使用 ArrayList :</p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。<br>以下情况使用 LinkedList :</li><li>你需要通过循环迭代来访问列表中的某些元素。需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><p>LinkedList and ArrayList 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以LinkedList初始化</span></span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 以ArrayList初始化</span></span><br><span class="line">        <span class="comment">// ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;();</span></span><br><span class="line">        sites.add(<span class="string">"This"</span>);</span><br><span class="line">        sites.add(<span class="string">"is"</span>);</span><br><span class="line">        sites.add(<span class="string">"a"</span>);</span><br><span class="line">        sites.add(<span class="string">"test"</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/images/15.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、-容器的概念&quot;&gt;&lt;a href=&quot;#1、-容器的概念&quot; class=&quot;headerlink&quot; title=&quot;1、 容器的概念&quot;&gt;&lt;/a&gt;1、 容器的概念&lt;/h3&gt;&lt;p&gt;在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2020/07/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-07-15T03:47:22.000Z</published>
    <updated>2020-07-15T04:57:26.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-正则表达式实例"><a href="#1-正则表达式实例" class="headerlink" title="1. 正则表达式实例"></a>1. 正则表达式实例</h3><p>一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World” 字符串。<br>.（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。<br>下表列出了一些正则表达式的实例及描述：</p><a id="more"></a><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>this is text</td><td>匹配字符串 “this is text”</td></tr><tr><td>this\s+is\s+text</td><td>注意字符串中的 \s+。匹配单词 “this” 后面的 \s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \s+ 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td></tr><tr><td>^\d+(.\d+)?</td><td>^ 定义了以什么开始，\d+ 匹配一个或多个数字，? 设置括号内的选项是可选的. 匹配 “.”，可以匹配的实例：”5”, “1.5” 和 “2.21”。</td></tr></tbody></table><h3 id="2-使用正则需用到的类"><a href="#2-使用正则需用到的类" class="headerlink" title="2. 使用正则需用到的类"></a>2. 使用正则需用到的类</h3><ol><li>Pattern: 是一个正则表达式的编译表示，接受一个正则表达式作为它的第一个参数。</li><li>Matcher: 是对输入字符串进行解释和匹配操作的引擎。需要调用Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</li><li>PatternSyntaxException: 表示一个正则表达式模式中的语法错误。<br>PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误.</li></ol><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getDescription()</td><td>获取错误的描述。</td></tr><tr><td>public int getIndex()</td><td>获取错误的索引。</td></tr><tr><td>public String getPattern()</td><td>获取错误的正则表达式模式。</td></tr><tr><td>public String getMessage()</td><td>返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。</td></tr></tbody></table><h3 id="3-正则表达式语法"><a href="#3-正则表达式语法" class="headerlink" title="3. 正则表达式语法"></a>3. 正则表达式语法</h3><p>在 Java 的正则表达式中，两个<code>\\</code>代表其他语言中的一个<code>\</code>，这也就是为什么表示一位数字的正则表达式是 <code>\\d</code>，而表示一个普通的反斜杠是 <code>\\\\</code>。</p><ul><li>常用的一些字符及说明</li></ul><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td>{n,}</td><td>n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td></tr><tr><td>{n,m}</td><td>m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td></tr><tr><td>.</td><td>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td></tr><tr><td>`x</td><td>y`</td></tr><tr><td>[xyz]</td><td>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td></tr><tr><td>[^xyz]</td><td>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td></tr><tr><td>[^a-z]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td></tr><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td></tr><tr><td>\B</td><td>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td></tr><tr><td>\d</td><td>数字字符匹配。等效于 [0-9]。</td></tr><tr><td>\D</td><td>非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td>\f</td><td>换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td></tr><tr><td>\t</td><td>制表符匹配。与 \x09 和 \cI 等效。</td></tr></tbody></table><p><code>tips:</code>当解释为正则表达式时，字符串字面值 “\b” 与单个退格字符匹配,而”\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\(hello\)”。</p><p>实例： 查找字符串中是否包了 test 子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      String content = <span class="string">"I am test from utestPtactice"</span>;</span><br><span class="line">      String pattern = <span class="string">".*test.*"</span>;</span><br><span class="line">      <span class="keyword">boolean</span> isMatch = Pattern.matches(pattern, content);</span><br><span class="line">      System.out.println(<span class="string">"字符串中是否包含了 'test' 子字符串? "</span> + isMatch);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img src="/images/10.jpg" alt=""></p><h4 id="3-1-matches-和-lookingAt-方法"><a href="#3-1-matches-和-lookingAt-方法" class="headerlink" title="3.1 matches 和 lookingAt 方法"></a>3.1 matches 和 lookingAt 方法</h4><p>matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。 lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLAG = <span class="string">"poo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT1 = <span class="string">"pooooooooooooooooo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT2 = <span class="string">"ooooopoooooooooooo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern pattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Matcher matcher1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Matcher matcher2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line">        pattern = Pattern.compile(FLAG);</span><br><span class="line">        matcher1 = pattern.matcher(INPUT1);</span><br><span class="line">        matcher2 = pattern.matcher(INPUT2);</span><br><span class="line">        System.out.println(<span class="string">"INPUT1_lookingAt(): "</span>+matcher1.lookingAt());</span><br><span class="line">        System.out.println(<span class="string">"INPUT1_matches(): "</span>+matcher1.matches());</span><br><span class="line">        System.out.println(<span class="string">"INPUT2_lookingAt(): "</span>+matcher2.lookingAt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img src="/images/11.jpg" alt=""></p><h4 id="3-2replaceFirst-和-replaceAll-方法"><a href="#3-2replaceFirst-和-replaceAll-方法" class="headerlink" title="3.2replaceFirst 和 replaceAll 方法"></a>3.2replaceFirst 和 replaceAll 方法</h4><p>replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String FLAG = <span class="string">"dog"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String INPUT = <span class="string">"The dog says hello. All dogs say hello."</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String REPLACE = <span class="string">"cat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(FLAG);</span><br><span class="line">        Matcher m = p.matcher(INPUT);</span><br><span class="line">        INPUT = m.replaceAll(REPLACE);</span><br><span class="line">        System.out.println(INPUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img src="/images/12.jpg" alt=""></p><h4 id="3-3appendReplacement-和-appendTail-方法"><a href="#3-3appendReplacement-和-appendTail-方法" class="headerlink" title="3.3appendReplacement 和 appendTail 方法"></a>3.3appendReplacement 和 appendTail 方法</h4><p>Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String FLAG = <span class="string">"a*b"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String INPUT = <span class="string">"aabfooaabfooabfoobkkk"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String REPLACE = <span class="string">"-"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(FLAG);</span><br><span class="line">        Matcher m = p.matcher(INPUT);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">            m.appendReplacement(sb,REPLACE);</span><br><span class="line">        &#125;</span><br><span class="line">        m.appendTail(sb);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img src="/images/13.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-正则表达式实例&quot;&gt;&lt;a href=&quot;#1-正则表达式实例&quot; class=&quot;headerlink&quot; title=&quot;1. 正则表达式实例&quot;&gt;&lt;/a&gt;1. 正则表达式实例&lt;/h3&gt;&lt;p&gt;一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World” 字符串。&lt;br&gt;.（点号）也是一个正则表达式，它匹配任何一个字符如：”a” 或 “1”。&lt;br&gt;下表列出了一些正则表达式的实例及描述：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JDBC的使用</title>
    <link href="http://yoursite.com/2020/07/14/JDBC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/14/JDBC%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-14T06:04:44.000Z</published>
    <updated>2020-07-14T06:53:59.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JDBC定义"><a href="#JDBC定义" class="headerlink" title="JDBC定义"></a>JDBC定义</h3><p>JDBC（Java DataBase Connectivity）是Java和数据库之间的一个桥梁，是一个规范而不是一个实现，能够执行SQL语句。它由一组用Java语言编写的类和接口组成，各种不同类型的数据库都有相应的实现。</p><h3 id="JDBC使用步骤"><a href="#JDBC使用步骤" class="headerlink" title="JDBC使用步骤"></a>JDBC使用步骤</h3><h4 id="1-装载相应数据库的JDBC驱动并进行初始化"><a href="#1-装载相应数据库的JDBC驱动并进行初始化" class="headerlink" title="1.装载相应数据库的JDBC驱动并进行初始化"></a>1.装载相应数据库的JDBC驱动并进行初始化</h4><ul><li>导入专用的jar包（不同的数据库需要的jar包不同），若无导包，后面会抛出ClassNotFoundException</li><li>初始化驱动<code>Class.forName</code><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">        <span class="comment">//注意：Class.forName需要捕获ClassNotFoundException.</span></span><br><span class="line">    e.printStackTrace();       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>tip：Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作.<h4 id="2-与数据库建立连接"><a href="#2-与数据库建立连接" class="headerlink" title="2.与数据库建立连接"></a>2.与数据库建立连接</h4>需提供</li></ul><ol><li>数据库服务端的IP地址:127.0.0.1 (这是本机，如果连接其他电脑上的数据库，需填写相应的IP地址)</li><li>数据库的端口号： 3306 （mysql专用端口号）</li><li>数据库名称 sqlname（根据你自己数据库中的名称填写）</li><li>编码方式 UTF-8</li><li>账号 root</li><li>密码 123456（如果你在创建数据库的时候没有使用默认的账号和密码，请填写自己设置的账号和密码）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/sqlname?characterEncoding=UTF-8"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure>tip: Connection是与特定数据库连接回话的接口，使用的时候需要导包，而且必须在程序结束的时候将其关闭。getConnection方法也需要捕获SQLException异常。</li></ol><ul><li>单独封装起来，因为在进行数据库的增删改查的时候都需要与数据库建立连接<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 取得数据库的连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个数据库的连接 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;           </span><br><span class="line">    Connection conn = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">//初始化驱动类com.mysql.jdbc.Driver           </span></span><br><span class="line">         Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);          </span><br><span class="line">         conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/sqlname?characterEncoding=UTF-8"</span>,<span class="string">"root"</span>, <span class="string">"123456"</span>);            </span><br><span class="line">         <span class="comment">//该类就在 mysql-connector-java-5.0.8-bin.jar中,如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException        </span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;             </span><br><span class="line">             e.printStackTrace();        </span><br><span class="line">         &#125;<span class="keyword">catch</span> (SQLException e) &#123;            </span><br><span class="line">             e.printStackTrace();       </span><br><span class="line">         &#125; </span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-创建Statement或者PreparedStatement接口，执行SQL语句"><a href="#3-创建Statement或者PreparedStatement接口，执行SQL语句" class="headerlink" title="3.创建Statement或者PreparedStatement接口，执行SQL语句"></a>3.创建Statement或者PreparedStatement接口，执行SQL语句</h3></li><li>使用Statement接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Statement s = conn.createStatement();</span><br><span class="line"><span class="comment">// 准备sql语句</span></span><br><span class="line"><span class="comment">// 注意： 字符串要用单引号'</span></span><br><span class="line">String sql = <span class="string">"insert into t_courses values(null,"</span>+<span class="string">"'数学')"</span>;</span><br><span class="line"><span class="comment">//在statement中使用字符串拼接的方式，这种方式存在诸多问题</span></span><br><span class="line">s.execute(sql);</span><br><span class="line">System.out.println(<span class="string">"执行插入语句成功"</span>);</span><br></pre></td></tr></table></figure></li><li>使用PreparedStatement接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 添加课程 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> courseName 课程名称 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCourse</span><span class="params">(String courseName)</span></span>&#123;</span><br><span class="line">     String sql = <span class="string">"insert into t_course(course_name) values(?)"</span>;   </span><br><span class="line">     <span class="comment">//该语句为每个 IN 参数保留一个问号（“？”）作为占位符</span></span><br><span class="line">     Connection conn = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//和数据库取得连接</span></span><br><span class="line">     PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//创建statement</span></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         conn = DbUtil.getConnection();</span><br><span class="line">         pstmt = (PreparedStatement) conn.prepareStatement(sql);</span><br><span class="line">         pstmt.setString(<span class="number">1</span>, courseName); <span class="comment">//给占位符赋值</span></span><br><span class="line">         pstmt.executeUpdate();<span class="comment">//执行</span></span><br><span class="line">         &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">             DbUtil.close(pstmt);</span><br><span class="line">             DbUtil.close(conn);<span class="comment">//必须关闭</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>tip:</li><li>使用PreparedStatement时，他的SQL语句不再采用字符串拼接的方式，而是采用占位符的方式。“？”在这里就起到占位符的作用。这种方式除了避免了statement拼接字符串的繁琐之外，还能够提高性能。每次SQL语句都是一样的，java类就不会再次编译，这样能够显著提高性能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"update t_course set course_name =? where course_id=?"</span>;</span><br></pre></td></tr></table></figure>后面需要用到PreparedStatement接口创建的pstmt的set方法给占位符进行赋值。注意一点，这里的参数索引是从1开始的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pstmt = (PreparedStatement) conn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, courseName);  <span class="comment">//利用Preparedstatement的set方法给占位符赋值</span></span><br><span class="line">pstmt.setInt(<span class="number">2</span>, courseId);pstmt.executeUpdate();</span><br></pre></td></tr></table></figure>增删改都使用<code>pstmt.executeUpdate()</code>语句进行SQL语句的提交 ，下文的查询会有所不同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 查询课程 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Course&gt; <span class="title">findCourseList</span><span class="params">()</span></span>&#123;</span><br><span class="line">     String sql = <span class="string">"select * from t_course order by course_id"</span>;</span><br><span class="line">     Connection conn = <span class="keyword">null</span>;</span><br><span class="line">     PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">     ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//创建一个集合对象用来存放查询到的数据</span></span><br><span class="line">     List&lt;Course&gt; courseList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = DbUtil.getConnection();</span><br><span class="line">         pstmt = (PreparedStatement) conn.prepareStatement(sql);</span><br><span class="line">         rs = (ResultSet) pstmt.executeQuery();</span><br><span class="line">         <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">             <span class="keyword">int</span> courseId = rs.getInt(<span class="string">"course_id"</span>);</span><br><span class="line">             String courseName = rs.getString(<span class="string">"course_name"</span>);</span><br><span class="line">             Course course = <span class="keyword">new</span> Course();<span class="comment">//每个记录对应一个对象</span></span><br><span class="line">             course.setCourseId(courseId);</span><br><span class="line">             course.setCourseName(courseName);</span><br><span class="line">             courseList.add(course);<span class="comment">//将对象放到集合中</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                 <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                DbUtil.close(pstmt);</span><br><span class="line">                DbUtil.close(conn);<span class="comment">//必须关闭</span></span><br><span class="line">        &#125;<span class="keyword">return</span> courseList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>tip: 查询操作使用<code>executeQuery()</code>进行更新<h3 id="4-处理和显示结果"><a href="#4-处理和显示结果" class="headerlink" title="4.处理和显示结果"></a>4.处理和显示结果</h3>执行查询语句，并把结果集返回给集合ResultSet<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = s.executeQuery(sql);</span><br></pre></td></tr></table></figure>利用While(ResultSet.next()){…}循环将集合ResultSet中的结果遍历出来。<br>ResultSet.getXX();这里的get方法的括号里面可以填属性值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">    <span class="keyword">int</span> courseId = rs.getInt(<span class="string">"course_id"</span>);</span><br><span class="line">    String courseName = rs.getString(<span class="string">"course_name"</span>);</span><br><span class="line">    <span class="comment">//每个记录对应一个对象</span></span><br><span class="line">    Course course = <span class="keyword">new</span> Course();</span><br><span class="line">    <span class="comment">//在项目中创建了course类，其中定义了set方法，所以这里将查询到的值传给了course，也可以直接打印到控制台</span></span><br><span class="line">    course.setCourseId(courseId);</span><br><span class="line">    course.setCourseName(courseName);</span><br><span class="line">    <span class="comment">//将对象放到集合中</span></span><br><span class="line">    courseList.add(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-释放资源"><a href="#5-释放资源" class="headerlink" title="5.释放资源"></a>5.释放资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 封装三个关闭方法 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pstmt </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(PreparedStatement pstmt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstmt != <span class="keyword">null</span>)&#123;<span class="comment">//避免出现空指针异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        pstmt.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JDBC定义&quot;&gt;&lt;a href=&quot;#JDBC定义&quot; class=&quot;headerlink&quot; title=&quot;JDBC定义&quot;&gt;&lt;/a&gt;JDBC定义&lt;/h3&gt;&lt;p&gt;JDBC（Java DataBase Connectivity）是Java和数据库之间的一个桥梁，是一个规范而不是一个实现，能够执行SQL语句。它由一组用Java语言编写的类和接口组成，各种不同类型的数据库都有相应的实现。&lt;/p&gt;
&lt;h3 id=&quot;JDBC使用步骤&quot;&gt;&lt;a href=&quot;#JDBC使用步骤&quot; class=&quot;headerlink&quot; title=&quot;JDBC使用步骤&quot;&gt;&lt;/a&gt;JDBC使用步骤&lt;/h3&gt;&lt;h4 id=&quot;1-装载相应数据库的JDBC驱动并进行初始化&quot;&gt;&lt;a href=&quot;#1-装载相应数据库的JDBC驱动并进行初始化&quot; class=&quot;headerlink&quot; title=&quot;1.装载相应数据库的JDBC驱动并进行初始化&quot;&gt;&lt;/a&gt;1.装载相应数据库的JDBC驱动并进行初始化&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;导入专用的jar包（不同的数据库需要的jar包不同），若无导包，后面会抛出ClassNotFoundException&lt;/li&gt;
&lt;li&gt;初始化驱动&lt;code&gt;Class.forName&lt;/code&gt;
    
    </summary>
    
    
    
      <category term="JDBC" scheme="http://yoursite.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>MVC架构基本原理</title>
    <link href="http://yoursite.com/2020/07/14/MVC%E6%9E%B6%E6%9E%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/14/MVC%E6%9E%B6%E6%9E%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2020-07-14T04:57:31.000Z</published>
    <updated>2020-07-14T05:57:34.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h3><p>Model - View - Controller</p><h4 id="1-1-Model"><a href="#1-1-Model" class="headerlink" title="1.1 Model"></a>1.1 Model</h4><p>与数据库的表相对应，可能是POCO，也可能是包含一些验证逻辑的实体类。在项目中，（简单理解）一般把数据访问和操作，比如将对象关系映射这样的代码作为Model层，也就是对数据库的操作这一些列的代码作为Model层。比如代码中我们会写DAO和DTO类型的代码，那这个DAO和DTO我们可以理解为是属于Model层的代码。</p><a id="more"></a><h4 id="1-2-View"><a href="#1-2-View" class="headerlink" title="1.2 View"></a>1.2 View</h4><p>视图，为用户提供使用界面，与用户直接进行交互。</p><h4 id="1-3-Controller"><a href="#1-3-Controller" class="headerlink" title="1.3 Controller"></a>1.3 Controller</h4><p>控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应(即响应到View）。</p><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2.工作流程"></a>2.工作流程</h3><ul><li>用户通过 View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等</li><li>服务端 Controller控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理</li><li>Model 处理后，将处理结果再交给 Controller</li><li>Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。</li></ul><p><img src="/images/9.jpg" alt=""></p><h3 id="3-与三层架构的关系"><a href="#3-与三层架构的关系" class="headerlink" title="3.与三层架构的关系"></a>3.与三层架构的关系</h3><h4 id="3-1-三层架构"><a href="#3-1-三层架构" class="headerlink" title="3.1 三层架构"></a>3.1 三层架构</h4><ol><li>View（表现层）：展现给用户的界面，即用户在使用一个系统的时候的所见所得。</li><li>Service（业务逻辑层）：对数据层的操作，对数据业务逻辑处理。</li><li>Dao（数据访问层): 直接操作数据库，针对数据的增添、删除、修改、更新、查找等。<h4 id="3-2-区别联系"><a href="#3-2-区别联系" class="headerlink" title="3.2 区别联系"></a>3.2 区别联系</h4>MVC 可以是三层中的一个表现层框架，属于表现层。三层和mvc可以共存。 三层是基于业务逻辑来分的，是一个架构设计，而MVC是基于页面来分的，是一种设计模式。<h3 id="4-使用MVC的理由"><a href="#4-使用MVC的理由" class="headerlink" title="4.使用MVC的理由"></a>4.使用MVC的理由</h3></li></ol><ul><li>优点：分层，结构清晰，耦合性低，大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率，维护方便，降低了维护成本。<h4 id="4-1-耦合性低"><a href="#4-1-耦合性低" class="headerlink" title="4.1 耦合性低"></a>4.1 耦合性低</h4>视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码,(例如，改写jsp,html,css,javascirpt的代码，并不需要重启服务器)同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可【例如，换表名查询，更改一些查询的条件，或者使用动态sql还是静态的sql，只用更改model即可】。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。<h4 id="4-2-重用性高"><a href="#4-2-重用性高" class="headerlink" title="4.2 重用性高"></a>4.2 重用性高</h4>随着技术的不断进步，需要用越来越多的方式来访问应用程序。MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB(HTTP)浏览器或者无线浏览器(wap)，比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。【例如，模型层实现了同样的分页，不同的视图层可以用一万种不同的显示方法，例如百度搜索下面的分页和谷歌搜索下面的分页】MVC使开发和维护用户接口的技术含量降低。<h4 id="4-3-部署快"><a href="#4-3-部署快" class="headerlink" title="4.3 部署快"></a>4.3 部署快</h4>使用MVC模式使开发时间得到相当大的缩减，它使程序员(Java开发人员)集中精力于业务逻辑，界面程序员(HTML和JSP开发人员)集中精力于表现形式上。【例如，前端后端可以分工作业，效率高，方便多开发人员间的分工】<h4 id="4-4-可维护性高"><a href="#4-4-可维护性高" class="headerlink" title="4.4 可维护性高"></a>4.4 可维护性高</h4>分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。【例如：如果想改业务逻辑，只用改业务逻辑，如果想改视图，只用改视图，如果想增加功能，只需要增加即可，分层最大的好处就是容易后期维护降低维护成本，和增加新的功能，提高代码重用性，从而提高开发效率】<h4 id="4-5-有利于软件工程化管理"><a href="#4-5-有利于软件工程化管理" class="headerlink" title="4.5 有利于软件工程化管理"></a>4.5 有利于软件工程化管理</h4>由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。控制器也提供了一个好处，就是可以使用控制器来联接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。【因为控制器重点在于分配，更好的结合视图和模型】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-组成&quot;&gt;&lt;a href=&quot;#1-组成&quot; class=&quot;headerlink&quot; title=&quot;1.组成&quot;&gt;&lt;/a&gt;1.组成&lt;/h3&gt;&lt;p&gt;Model - View - Controller&lt;/p&gt;
&lt;h4 id=&quot;1-1-Model&quot;&gt;&lt;a href=&quot;#1-1-Model&quot; class=&quot;headerlink&quot; title=&quot;1.1 Model&quot;&gt;&lt;/a&gt;1.1 Model&lt;/h4&gt;&lt;p&gt;与数据库的表相对应，可能是POCO，也可能是包含一些验证逻辑的实体类。在项目中，（简单理解）一般把数据访问和操作，比如将对象关系映射这样的代码作为Model层，也就是对数据库的操作这一些列的代码作为Model层。比如代码中我们会写DAO和DTO类型的代码，那这个DAO和DTO我们可以理解为是属于Model层的代码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="http://yoursite.com/2020/07/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-06T11:58:45.000Z</published>
    <updated>2020-07-06T13:08:51.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><ul><li>定义：定义一个创建产品对象的工厂接口，将产品对象的实际创 建工作推迟到具体子工厂类当中。</li><li>特点：满足创建型模式中所要求的“创建与使用相分离”的特点。但是增加新产品时会违背“开闭原则”。<a id="more"></a><h3 id="模式的结构图"><a href="#模式的结构图" class="headerlink" title="模式的结构图"></a>模式的结构图</h3><img src="/images/1.jpg" alt=""><h3 id="模式的优缺点"><a href="#模式的优缺点" class="headerlink" title="模式的优缺点"></a>模式的优缺点</h3></li><li>优点： </li></ul><ol><li>用户知道具体工厂的名称就可得到所要的产品，无须知道产品的创建过程</li><li>增加新的产品时只需要添加具体产品类和对应的具体工厂类，无需修改源代码，满足开闭原则。 </li></ol><ul><li>缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h3 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h3><p>例：用工厂方法 模式设计畜牧场。<br>分析：有很多种类的 畜牧场，如养马场用于养 马，养牛场用于养牛。<br>结构图如下：<br><img src="/images/2.jpg" alt=""></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在前面介绍的工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类）的产品，如农场里既养动物又种植物，电器厂既生成电视机又生成洗衣机或空调，大学既有软件专业又有生物专业等。 </p><h3 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h3><ul><li>定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 </li><li>使用抽象工厂模式一般要满足以下条件：</li></ul><ol><li>系统中有多个产品族，每个具体工厂创建同一族的但属于不同等级结构 的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ol><h3 id="模式的结构图-1"><a href="#模式的结构图-1" class="headerlink" title="模式的结构图"></a>模式的结构图</h3><p><img src="/images/3.jpg" alt=""></p><h3 id="模式的优缺点-1"><a href="#模式的优缺点-1" class="headerlink" title="模式的优缺点"></a>模式的优缺点</h3><ul><li>优点：</li></ul><ol><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理；</li><li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。 </li></ol><ul><li>缺点：当产品族中需要增加一个新等级的产品时，则所有的工厂类都需要进行修改。</li></ul><h3 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h3><p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性： </p><ol><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则</li></ol><h3 id="模式的应用实例-1"><a href="#模式的应用实例-1" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h3><p> 例：用抽象工厂模式设计农场类。<br> 分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等。<br> 结构图如下：<br> <img src="/images/4.jpg" alt=""></p><ul><li>假设新增加了一个农场 NDfarm，可以养牛养蔬菜，则类图更改步骤如下：</li></ul><ol><li>新加入一个NDfarm类，实现 Farm接口，里面包含newAnimal和newPlant方法。 </li><li>连接到cattle类和 vegetables类</li></ol><ul><li>假设SR、Sg两个农场都需要 新加入一个角色“农夫”,则类图更改步骤如下：</li></ul><ol><li>新加入一个People接口 </li><li>新加入一个nongfu类，实现People接口 </li><li>在Farm，SR和Sg三个类中，加入newNongfu方法，连接到nongfu</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模式的定义与特点&quot;&gt;&lt;a href=&quot;#模式的定义与特点&quot; class=&quot;headerlink&quot; title=&quot;模式的定义与特点&quot;&gt;&lt;/a&gt;模式的定义与特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：定义一个创建产品对象的工厂接口，将产品对象的实际创 建工作推迟到具体子工厂类当中。&lt;/li&gt;
&lt;li&gt;特点：满足创建型模式中所要求的“创建与使用相分离”的特点。但是增加新产品时会违背“开闭原则”。
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="创建型模式" scheme="http://yoursite.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://yoursite.com/2020/07/05/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/05/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-05T13:18:21.000Z</published>
    <updated>2020-07-06T13:37:40.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h3><ul><li>定义：指多个对象间存在一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式<a id="more"></a><h3 id="模式的结构图"><a href="#模式的结构图" class="headerlink" title="模式的结构图"></a>模式的结构图</h3><img src="/images/7.jpg" alt=""><h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obs:observers)&#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式的优缺点"><a href="#模式的优缺点" class="headerlink" title="模式的优缺点"></a>模式的优缺点</h3></li><li>优点：</li></ul><ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系； </li><li>目标与观察者之间建立了一套触发机制。</li></ol><ul><li>缺点：</li></ul><ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用； </li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ol><h3 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h3><p>例：利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或 出口公司的出口产品收入以及公司的利润率的影响。 </p><p>分析：：当“人民币汇率”升值时， 进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降 低且利润率降低；当“人民币汇率” 贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。</p><p>结构图如下：<br><img src="/images/8.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模式的定义&quot;&gt;&lt;a href=&quot;#模式的定义&quot; class=&quot;headerlink&quot; title=&quot;模式的定义&quot;&gt;&lt;/a&gt;模式的定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：指多个对象间存在一对多的依赖关系，当一个对象的状态 发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="行为型模式" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://yoursite.com/2020/07/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-04T12:34:54.000Z</published>
    <updated>2020-07-06T13:39:57.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h3><ul><li>定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<a id="more"></a><h3 id="模式的结构图"><a href="#模式的结构图" class="headerlink" title="模式的结构图"></a>模式的结构图</h3><img src="/images/5.jpg" alt=""><h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realSubject==<span class="keyword">null</span>)&#123;</span><br><span class="line">            realSubject =<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式应用实例"><a href="#模式应用实例" class="headerlink" title="模式应用实例"></a>模式应用实例</h3>例：韶关“天街e角”公司是一家婺源特产公司的代理公司，用代理模式实现。<br>分析：韶关“天街e角”公司是婺源特产公司特产的代理，通过调用婺源特产公司的 <code>display()</code> 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“婺源特产公司”的产品。<br>结构图如下：<br><img src="/images/6.jpg" alt=""><h3 id="模式的优缺点"><a href="#模式的优缺点" class="headerlink" title="模式的优缺点"></a>模式的优缺点</h3></li><li>优点：</li></ul><ol><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与 目标对象分离在一定程度上降低了系统的耦合度。 </li></ol><ul><li>缺点：</li></ul><ol><li>在客户端和目标对象增加一个代理对象,会造成请求处理速度变慢；</li><li>增加了系统的复杂度。 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模式的定义&quot;&gt;&lt;a href=&quot;#模式的定义&quot; class=&quot;headerlink&quot; title=&quot;模式的定义&quot;&gt;&lt;/a&gt;模式的定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="结构型模式" scheme="http://yoursite.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git的基本使用</title>
    <link href="http://yoursite.com/2020/07/03/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/03/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-03T11:54:28.000Z</published>
    <updated>2020-07-03T13:06:52.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git上传项目"><a href="#Git上传项目" class="headerlink" title="Git上传项目"></a>Git上传项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GitHub新建仓库，复制地址</span><br><span class="line">在所要上传的项目右键， git bash here</span><br><span class="line">git init //生成 .git 文件</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"要提交的信息”</span></span><br><span class="line"><span class="string">git remote add origin + 复制的地址  //本地添加git上的远程仓库，起名origin</span></span><br><span class="line"><span class="string">git push -u origin master   //把本地的分支推到远程仓master主分支进行保存</span></span><br></pre></td></tr></table></figure> <a id="more"></a><h2 id="Git创建提交分支"><a href="#Git创建提交分支" class="headerlink" title="Git创建提交分支"></a>Git创建提交分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch  //检查当前所在分支</span><br><span class="line">git checkout -b user  //创建一个user新分支，并切换到该分支上</span><br><span class="line">git add .  //添加所有文件到暂存区</span><br><span class="line">git commit -m <span class="string">"提交的信息"</span></span><br><span class="line">git push origin 新分支 //将新建分支推送到远程分支</span><br></pre></td></tr></table></figure><h2 id="分支合并到-master-里"><a href="#分支合并到-master-里" class="headerlink" title="分支合并到 master 里"></a>分支合并到 master 里</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master //切换到主分支</span><br><span class="line">git merge branchName // branchName为想要合并的分支名</span><br><span class="line">git push origin master //推送当前合并过的master分支到远程仓库</span><br></pre></td></tr></table></figure><h2 id="git-add的使用"><a href="#git-add的使用" class="headerlink" title="git add的使用"></a>git add的使用</h2><p>1.基本语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;path&gt;</span><br></pre></td></tr></table></figure><p> <path>可以是文件也可以是目录。git不仅能判断出<path>中，修改(不包括已删除)的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。</p><p>2.示例<br>添加documentation目录及其子目录下所有*.txt文件的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add documentation/*.txt</span><br></pre></td></tr></table></figure><h2 id="git-pull的使用"><a href="#git-pull的使用" class="headerlink" title="git pull的使用"></a>git pull的使用</h2><p>1.基本语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 远程主机名 远程分支名 ：本地分支名</span><br></pre></td></tr></table></figure><p>2.示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin next : master //取回origin主机的 next 分支，与本地 mater 合并</span><br><span class="line">git pull origin next //远程分支与当前所在分支合并，可省略 ：后的部分</span><br></pre></td></tr></table></figure><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream master origin/next //手动建立追踪关系，指定master分支追踪origin/next分支。</span><br><span class="line">git pull origin //若当前分支与远程分支存在追踪关系，则可省略远程分支名,本地的当前分支自动与对应的origin主机”追踪分支进行合并</span><br><span class="line">git pull //若当前分支只有一个追踪分支，则远程主机名可省略</span><br></pre></td></tr></table></figure><h2 id="git-push的使用"><a href="#git-push的使用" class="headerlink" title="git push的使用"></a>git push的使用</h2><p>1.基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push 远程主机名 本地分支名 ：远程分支名</span><br></pre></td></tr></table></figure><p>2.示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">//将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。</span><br><span class="line">git push origin</span><br><span class="line">//如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</span><br><span class="line">git push</span><br><span class="line">//如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><br><span class="line">git push -u origin master</span><br><span class="line">//如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</span><br><span class="line">git push --all origin</span><br><span class="line">//不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</span><br><span class="line">git push origin HEAD</span><br><span class="line">//当前分支推送到远程的同名的分支</span><br><span class="line">git push origin A:refs/B</span><br><span class="line">//推送本地分支 A 到新远程分支 B</span><br></pre></td></tr></table></figure><p>推送 A 到已有的 B，用于补充 B：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout  A</span><br><span class="line">git rebase B  //该命令在B分支基础之上重新应用，用于把B分支相对于A分支的修改合并到当前A分支</span><br><span class="line">git push origin A:refs/B</span><br><span class="line">```</span><br><span class="line">用本地分支 A 覆盖远程分支 B：</span><br><span class="line">``` bash</span><br><span class="line">git push -f origin A:refs/B</span><br></pre></td></tr></table></figure><h2 id="git删除分支"><a href="#git删除分支" class="headerlink" title="git删除分支"></a>git删除分支</h2><p> 1.删除本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><p>注意：要切换到其他分支上才可以对该分支进行删除； 若与某进程冲突时，打开隐藏文件夹选项，把 .git 里的 index.lock 文件删掉</p><p>2.删除远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :分支名</span><br></pre></td></tr></table></figure><p>注意: 冒号前有个空格，该操作相当与把空分支覆盖远程分支）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git上传项目&quot;&gt;&lt;a href=&quot;#Git上传项目&quot; class=&quot;headerlink&quot; title=&quot;Git上传项目&quot;&gt;&lt;/a&gt;Git上传项目&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GitHub新建仓库，复制地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在所要上传的项目右键， git bash here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init //生成 .git 文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;要提交的信息”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;git remote add origin + 复制的地址  //本地添加git上的远程仓库，起名origin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;git push -u origin master   //把本地的分支推到远程仓master主分支进行保存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2020/07/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-01T10:27:21.000Z</published>
    <updated>2020-07-06T13:40:07.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><ul><li>定义： 指一个类只有一个实例，且该类能自行创建这个实例的一 种模式。例如，Windows中的任务管理器、回收站等。 </li><li>特点：<br>1、单例类只有一个实例对象<br>2、该单例对象必须由单例类自行创建<br>3、单例类对外提供一个访问该单例的全局访问点<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;   </span><br><span class="line">    <span class="comment">//让构造函数为 private，这样该类就不会被外部实例化 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123; &#125; </span><br><span class="line">    <span class="comment">//类里new 创建一个私有实例 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="comment">//向外提供一个公有函数用于获取该私有实例 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(“Hello World!”);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3> 该模式的特点是类一旦加载就创建一个单例，保证在调用getInstance方法之前 单例已经存在了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton(); </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123; &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>是否 Lazy 初始化：否 </li><li>是否多线程安全：是 </li><li>实现难度：易 </li><li>描述：这种方式比较常用，但容易产生垃圾对象。 </li><li>优点：没有加锁，执行效率会提高。 </li><li>缺点：类加载时就初始化，浪费内存。<h3 id="懒汉式单例（不安全）"><a href="#懒汉式单例（不安全）" class="headerlink" title="懒汉式单例（不安全）"></a>懒汉式单例（不安全）</h3> 该模式的特点是类加载时没有生成单例，只有当第一次调用getInstance方法 时才去创建这个单例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance=<span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  instance=<span class="keyword">new</span> LazySingleton();  &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>是否 Lazy 初始化：是 </li><li>是否多线程安全：否 </li><li>实现难度：易 </li><li>描述：这种方式是基本的实现方式，这种实现大的问题就是不支持多线程。 </li><li>这种方式 lazy loading 很明显，不要求线程安全，在多线程情况下不能正常工作。<h3 id="懒汉式单例（安全）"><a href="#懒汉式单例（安全）" class="headerlink" title="懒汉式单例（安全）"></a>懒汉式单例（安全）</h3> 该模式的特点是类加载时没有生成单例，只有当第一次调用getInstance方法时才 去创建这个单例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="keyword">null</span>;<span class="comment">//保证instance在所 有线程中同步 </span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123; &#125; <span class="comment">//private避免类在外部被实例化 </span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//getInstance 方法前加同步 </span></span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  instance=<span class="keyword">new</span> LazySingleton();  &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>是否 Lazy 初始化：是 </li><li>是否多线程安全：是 </li><li>实现难度：易 </li><li>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是， 效率很低。 </li><li>优点：第一次调用才初始化，避免内存浪费。 </li><li>缺点：必须加锁 <code>synchronized</code> 才能保证单例，但加锁会影响效率。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模式的定义与特点&quot;&gt;&lt;a href=&quot;#模式的定义与特点&quot; class=&quot;headerlink&quot; title=&quot;模式的定义与特点&quot;&gt;&lt;/a&gt;模式的定义与特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定义： 指一个类只有一个实例，且该类能自行创建这个实例的一 种模式。例如，Windows中的任务管理器、回收站等。 &lt;/li&gt;
&lt;li&gt;特点：&lt;br&gt;1、单例类只有一个实例对象&lt;br&gt;2、该单例对象必须由单例类自行创建&lt;br&gt;3、单例类对外提供一个访问该单例的全局访问点
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="创建型模式" scheme="http://yoursite.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
